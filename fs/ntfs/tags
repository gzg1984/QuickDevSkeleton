!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.7	//
ACCESS_ALLOWED_ACE	layout.h	/^} __attribute__ ((__packed__)) ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE,$/;"	t	typeref:struct:__anon77
ACCESS_ALLOWED_ACE_TYPE	layout.h	/^	ACCESS_ALLOWED_ACE_TYPE		= 0,$/;"	e	enum:__anon72
ACCESS_ALLOWED_COMPOUND_ACE_TYPE	layout.h	/^	ACCESS_ALLOWED_COMPOUND_ACE_TYPE= 4,$/;"	e	enum:__anon72
ACCESS_ALLOWED_OBJECT_ACE	layout.h	/^} __attribute__ ((__packed__)) ACCESS_ALLOWED_OBJECT_ACE,$/;"	t	typeref:struct:__anon79
ACCESS_ALLOWED_OBJECT_ACE_TYPE	layout.h	/^	ACCESS_ALLOWED_OBJECT_ACE_TYPE	= 5,$/;"	e	enum:__anon72
ACCESS_DENIED_ACE	layout.h	/^} __attribute__ ((__packed__)) ACCESS_ALLOWED_ACE, ACCESS_DENIED_ACE,$/;"	t	typeref:struct:__anon77
ACCESS_DENIED_ACE_TYPE	layout.h	/^	ACCESS_DENIED_ACE_TYPE		= 1,$/;"	e	enum:__anon72
ACCESS_DENIED_OBJECT_ACE	layout.h	/^			       ACCESS_DENIED_OBJECT_ACE,$/;"	t	typeref:struct:__anon79
ACCESS_DENIED_OBJECT_ACE_TYPE	layout.h	/^	ACCESS_DENIED_OBJECT_ACE_TYPE	= 6,$/;"	e	enum:__anon72
ACCESS_MASK	layout.h	/^typedef le32 ACCESS_MASK;$/;"	t
ACCESS_MAX_MS_ACE_TYPE	layout.h	/^	ACCESS_MAX_MS_ACE_TYPE		= 8,$/;"	e	enum:__anon72
ACCESS_MAX_MS_OBJECT_ACE_TYPE	layout.h	/^	ACCESS_MAX_MS_OBJECT_ACE_TYPE	= 8,$/;"	e	enum:__anon72
ACCESS_MAX_MS_V2_ACE_TYPE	layout.h	/^	ACCESS_MAX_MS_V2_ACE_TYPE	= 3,$/;"	e	enum:__anon72
ACCESS_MAX_MS_V3_ACE_TYPE	layout.h	/^	ACCESS_MAX_MS_V3_ACE_TYPE	= 4,$/;"	e	enum:__anon72
ACCESS_MAX_MS_V4_ACE_TYPE	layout.h	/^	ACCESS_MAX_MS_V4_ACE_TYPE	= 8,$/;"	e	enum:__anon72
ACCESS_MIN_MS_ACE_TYPE	layout.h	/^	ACCESS_MIN_MS_ACE_TYPE		= 0,$/;"	e	enum:__anon72
ACCESS_MIN_MS_OBJECT_ACE_TYPE	layout.h	/^	ACCESS_MIN_MS_OBJECT_ACE_TYPE	= 5,$/;"	e	enum:__anon72
ACCESS_SYSTEM_SECURITY	layout.h	/^	ACCESS_SYSTEM_SECURITY		= cpu_to_le32(0x01000000),$/;"	e	enum:__anon75
ACE_FLAGS	layout.h	/^typedef u8 ACE_FLAGS;$/;"	t
ACE_HEADER	layout.h	/^} __attribute__ ((__packed__)) ACE_HEADER;$/;"	t	typeref:struct:__anon74
ACE_INHERITED_OBJECT_TYPE_PRESENT	layout.h	/^	ACE_INHERITED_OBJECT_TYPE_PRESENT	= cpu_to_le32(2),$/;"	e	enum:__anon78
ACE_OBJECT_TYPE_PRESENT	layout.h	/^	ACE_OBJECT_TYPE_PRESENT			= cpu_to_le32(1),$/;"	e	enum:__anon78
ACE_TYPES	layout.h	/^typedef u8 ACE_TYPES;$/;"	t
ACL	layout.h	/^} __attribute__ ((__packed__)) ACL;$/;"	t	typeref:struct:__anon80
ACL_CONSTANTS	layout.h	/^} ACL_CONSTANTS;$/;"	t	typeref:enum:__anon81
ACL_REVISION	layout.h	/^	ACL_REVISION		= 2,$/;"	e	enum:__anon81
ACL_REVISION1	layout.h	/^	ACL_REVISION1		= 1,$/;"	e	enum:__anon81
ACL_REVISION2	layout.h	/^	ACL_REVISION2		= 2,$/;"	e	enum:__anon81
ACL_REVISION3	layout.h	/^	ACL_REVISION3		= 3,$/;"	e	enum:__anon81
ACL_REVISION4	layout.h	/^	ACL_REVISION4		= 4,$/;"	e	enum:__anon81
ACL_REVISION_DS	layout.h	/^	ACL_REVISION_DS		= 4,$/;"	e	enum:__anon81
ATTR_COMPRESSION_MASK	layout.h	/^	ATTR_COMPRESSION_MASK = cpu_to_le16(0x00ff), \/* Compression method$/;"	e	enum:__anon43
ATTR_DEF	layout.h	/^} __attribute__ ((__packed__)) ATTR_DEF;$/;"	t	typeref:struct:__anon42
ATTR_DEF_ALWAYS_LOG	layout.h	/^	ATTR_DEF_ALWAYS_LOG	= cpu_to_le32(0x80), \/* Always log$/;"	e	enum:__anon41
ATTR_DEF_FLAGS	layout.h	/^typedef le32 ATTR_DEF_FLAGS;$/;"	t
ATTR_DEF_INDEXABLE	layout.h	/^	ATTR_DEF_INDEXABLE	= cpu_to_le32(0x02), \/* Attribute can be$/;"	e	enum:__anon41
ATTR_DEF_INDEXED_UNIQUE	layout.h	/^	ATTR_DEF_INDEXED_UNIQUE	= cpu_to_le32(0x10), \/* Attribute must be$/;"	e	enum:__anon41
ATTR_DEF_MULTIPLE	layout.h	/^	ATTR_DEF_MULTIPLE	= cpu_to_le32(0x04), \/* Attribute type$/;"	e	enum:__anon41
ATTR_DEF_NAMED_UNIQUE	layout.h	/^	ATTR_DEF_NAMED_UNIQUE	= cpu_to_le32(0x20), \/* Attribute must be$/;"	e	enum:__anon41
ATTR_DEF_NOT_ZERO	layout.h	/^	ATTR_DEF_NOT_ZERO	= cpu_to_le32(0x08), \/* Attribute value$/;"	e	enum:__anon41
ATTR_DEF_RESIDENT	layout.h	/^	ATTR_DEF_RESIDENT	= cpu_to_le32(0x40), \/* Attribute must be$/;"	e	enum:__anon41
ATTR_FLAGS	layout.h	/^typedef le16 ATTR_FLAGS;$/;"	t
ATTR_IS_COMPRESSED	layout.h	/^	ATTR_IS_COMPRESSED    = cpu_to_le16(0x0001),$/;"	e	enum:__anon43
ATTR_IS_ENCRYPTED	layout.h	/^	ATTR_IS_ENCRYPTED     = cpu_to_le16(0x4000),$/;"	e	enum:__anon43
ATTR_IS_SPARSE	layout.h	/^	ATTR_IS_SPARSE	      = cpu_to_le16(0x8000),$/;"	e	enum:__anon43
ATTR_LIST_ENTRY	layout.h	/^} __attribute__ ((__packed__)) ATTR_LIST_ENTRY;$/;"	t	typeref:struct:__anon54
ATTR_REC	layout.h	/^typedef ATTR_RECORD ATTR_REC;$/;"	t
ATTR_RECORD	layout.h	/^} __attribute__ ((__packed__)) ATTR_RECORD;$/;"	t	typeref:struct:__anon45
ATTR_TYPE	layout.h	/^typedef le32 ATTR_TYPE;$/;"	t
AT_ATTRIBUTE_LIST	layout.h	/^	AT_ATTRIBUTE_LIST		= cpu_to_le32(      0x20),$/;"	e	enum:__anon39
AT_BITMAP	layout.h	/^	AT_BITMAP			= cpu_to_le32(      0xb0),$/;"	e	enum:__anon39
AT_DATA	layout.h	/^	AT_DATA				= cpu_to_le32(      0x80),$/;"	e	enum:__anon39
AT_EA	layout.h	/^	AT_EA				= cpu_to_le32(      0xe0),$/;"	e	enum:__anon39
AT_EA_INFORMATION	layout.h	/^	AT_EA_INFORMATION		= cpu_to_le32(      0xd0),$/;"	e	enum:__anon39
AT_END	layout.h	/^	AT_END				= cpu_to_le32(0xffffffff)$/;"	e	enum:__anon39
AT_FILE_NAME	layout.h	/^	AT_FILE_NAME			= cpu_to_le32(      0x30),$/;"	e	enum:__anon39
AT_FIRST_USER_DEFINED_ATTRIBUTE	layout.h	/^	AT_FIRST_USER_DEFINED_ATTRIBUTE	= cpu_to_le32(    0x1000),$/;"	e	enum:__anon39
AT_INDEX_ALLOCATION	layout.h	/^	AT_INDEX_ALLOCATION		= cpu_to_le32(      0xa0),$/;"	e	enum:__anon39
AT_INDEX_ROOT	layout.h	/^	AT_INDEX_ROOT			= cpu_to_le32(      0x90),$/;"	e	enum:__anon39
AT_LOGGED_UTILITY_STREAM	layout.h	/^	AT_LOGGED_UTILITY_STREAM	= cpu_to_le32(     0x100),$/;"	e	enum:__anon39
AT_OBJECT_ID	layout.h	/^	AT_OBJECT_ID			= cpu_to_le32(      0x40),$/;"	e	enum:__anon39
AT_PROPERTY_SET	layout.h	/^	AT_PROPERTY_SET			= cpu_to_le32(      0xf0),$/;"	e	enum:__anon39
AT_REPARSE_POINT	layout.h	/^	AT_REPARSE_POINT		= cpu_to_le32(      0xc0),$/;"	e	enum:__anon39
AT_SECURITY_DESCRIPTOR	layout.h	/^	AT_SECURITY_DESCRIPTOR		= cpu_to_le32(      0x50),$/;"	e	enum:__anon39
AT_STANDARD_INFORMATION	layout.h	/^	AT_STANDARD_INFORMATION		= cpu_to_le32(      0x10),$/;"	e	enum:__anon39
AT_UNUSED	layout.h	/^	AT_UNUSED			= cpu_to_le32(         0),$/;"	e	enum:__anon39
AT_VOLUME_INFORMATION	layout.h	/^	AT_VOLUME_INFORMATION		= cpu_to_le32(      0x70),$/;"	e	enum:__anon39
AT_VOLUME_NAME	layout.h	/^	AT_VOLUME_NAME			= cpu_to_le32(      0x60),$/;"	e	enum:__anon39
BIOS_PARAMETER_BLOCK	layout.h	/^} __attribute__ ((__packed__)) BIOS_PARAMETER_BLOCK;$/;"	t	typeref:struct:__anon31
BITMAP_ATTR	layout.h	/^} __attribute__ ((__packed__)) BITMAP_ATTR;$/;"	t	typeref:struct:__anon113
BOOL	namei.c	/^typedef bool BOOL;$/;"	t	file:
CASE_SENSITIVE	types.h	/^	CASE_SENSITIVE = 0,$/;"	e	enum:__anon20
COLLATION_BINARY	layout.h	/^	COLLATION_BINARY		= cpu_to_le32(0x00),$/;"	e	enum:__anon40
COLLATION_FILE_NAME	layout.h	/^	COLLATION_FILE_NAME		= cpu_to_le32(0x01),$/;"	e	enum:__anon40
COLLATION_NTOFS_SECURITY_HASH	layout.h	/^	COLLATION_NTOFS_SECURITY_HASH	= cpu_to_le32(0x12),$/;"	e	enum:__anon40
COLLATION_NTOFS_SID	layout.h	/^	COLLATION_NTOFS_SID		= cpu_to_le32(0x11),$/;"	e	enum:__anon40
COLLATION_NTOFS_ULONG	layout.h	/^	COLLATION_NTOFS_ULONG		= cpu_to_le32(0x10),$/;"	e	enum:__anon40
COLLATION_NTOFS_ULONGS	layout.h	/^	COLLATION_NTOFS_ULONGS		= cpu_to_le32(0x13),$/;"	e	enum:__anon40
COLLATION_RULE	layout.h	/^typedef le32 COLLATION_RULE;$/;"	t
COLLATION_UNICODE_STRING	layout.h	/^	COLLATION_UNICODE_STRING	= cpu_to_le32(0x02),$/;"	e	enum:__anon40
CONFIG_BLOCK	ntfs_g.h	85;"	d
CONTAINER_INHERIT_ACE	layout.h	/^	CONTAINER_INHERIT_ACE		= 0x02,$/;"	e	enum:__anon73
DATA_ATTR	layout.h	/^} __attribute__ ((__packed__)) DATA_ATTR;$/;"	t	typeref:struct:__anon93
DATA_ZONE	lcnalloc.h	/^	DATA_ZONE	= 1,	\/* Allocate from $DATA zone. *\/$/;"	e	enum:__anon23
DCACHE_BUG	ntfs_g.h	4;"	d
DEFINE_MUTEX	mutex.h	107;"	d
DEFINE_MUTEX	ntfs_g.h	27;"	d
DEFINE_NVOL_BIT_OPS	volume.h	153;"	d
DELETE	layout.h	/^	DELETE				= cpu_to_le32(0x00010000),$/;"	e	enum:__anon75
DOMAIN_ALIAS_RID_ACCOUNT_OPS	layout.h	/^	DOMAIN_ALIAS_RID_ACCOUNT_OPS	  = 0x224,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_ADMINS	layout.h	/^	DOMAIN_ALIAS_RID_ADMINS		  = 0x220,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_BACKUP_OPS	layout.h	/^	DOMAIN_ALIAS_RID_BACKUP_OPS	  = 0x227,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_GUESTS	layout.h	/^	DOMAIN_ALIAS_RID_GUESTS		  = 0x222,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_POWER_USERS	layout.h	/^	DOMAIN_ALIAS_RID_POWER_USERS	  = 0x223,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_PREW2KCOMPACCESS	layout.h	/^	DOMAIN_ALIAS_RID_PREW2KCOMPACCESS = 0x22a,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_PRINT_OPS	layout.h	/^	DOMAIN_ALIAS_RID_PRINT_OPS	  = 0x226,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_RAS_SERVERS	layout.h	/^	DOMAIN_ALIAS_RID_RAS_SERVERS	  = 0x229,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_REPLICATOR	layout.h	/^	DOMAIN_ALIAS_RID_REPLICATOR	  = 0x228,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_SYSTEM_OPS	layout.h	/^	DOMAIN_ALIAS_RID_SYSTEM_OPS	  = 0x225,$/;"	e	enum:__anon67
DOMAIN_ALIAS_RID_USERS	layout.h	/^	DOMAIN_ALIAS_RID_USERS		  = 0x221,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_ADMINS	layout.h	/^	DOMAIN_GROUP_RID_ADMINS		  = 0x200,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_CERT_ADMINS	layout.h	/^	DOMAIN_GROUP_RID_CERT_ADMINS	  = 0x205,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_COMPUTERS	layout.h	/^	DOMAIN_GROUP_RID_COMPUTERS	  = 0x203,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_CONTROLLERS	layout.h	/^	DOMAIN_GROUP_RID_CONTROLLERS	  = 0x204,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_ENTERPRISE_ADMINS	layout.h	/^	DOMAIN_GROUP_RID_ENTERPRISE_ADMINS= 0x207,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_GUESTS	layout.h	/^	DOMAIN_GROUP_RID_GUESTS		  = 0x202,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_POLICY_ADMINS	layout.h	/^	DOMAIN_GROUP_RID_POLICY_ADMINS	  = 0x208,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_SCHEMA_ADMINS	layout.h	/^	DOMAIN_GROUP_RID_SCHEMA_ADMINS	  = 0x206,$/;"	e	enum:__anon67
DOMAIN_GROUP_RID_USERS	layout.h	/^	DOMAIN_GROUP_RID_USERS		  = 0x201,$/;"	e	enum:__anon67
DOMAIN_USER_RID_ADMIN	layout.h	/^	DOMAIN_USER_RID_ADMIN		  = 0x1f4,$/;"	e	enum:__anon67
DOMAIN_USER_RID_GUEST	layout.h	/^	DOMAIN_USER_RID_GUEST		  = 0x1f5,$/;"	e	enum:__anon67
DOMAIN_USER_RID_KRBTGT	layout.h	/^	DOMAIN_USER_RID_KRBTGT		  = 0x1f6,$/;"	e	enum:__anon67
DefaultLogPageSize	logfile.h	61;"	d
EA_ATTR	layout.h	/^} __attribute__ ((__packed__)) EA_ATTR;$/;"	t	typeref:struct:__anon118
EA_FLAGS	layout.h	/^typedef u8 EA_FLAGS;$/;"	t
EA_INFORMATION	layout.h	/^} __attribute__ ((__packed__)) EA_INFORMATION;$/;"	t	typeref:struct:__anon116
EFS_ATTR	layout.h	/^} __attribute__ ((__packed__)) LOGGED_UTILITY_STREAM, EFS_ATTR;$/;"	t	typeref:struct:__anon120
ERR_MREF	layout.h	318;"	d
EXTRA_CFLAGS	Makefile	/^EXTRA_CFLAGS = -DNTFS_VERSION=\\"2.1.29\\"$/;"	m
FAILED_ACCESS_ACE_FLAG	layout.h	/^	FAILED_ACCESS_ACE_FLAG		= 0x80,$/;"	e	enum:__anon73
FILE_ADD_FILE	layout.h	/^	FILE_ADD_FILE			= cpu_to_le32(0x00000002),$/;"	e	enum:__anon75
FILE_ADD_SUBDIRECTORY	layout.h	/^	FILE_ADD_SUBDIRECTORY		= cpu_to_le32(0x00000004),$/;"	e	enum:__anon75
FILE_APPEND_DATA	layout.h	/^	FILE_APPEND_DATA		= cpu_to_le32(0x00000004),$/;"	e	enum:__anon75
FILE_ATTR_ARCHIVE	layout.h	/^	FILE_ATTR_ARCHIVE		= cpu_to_le32(0x00000020),$/;"	e	enum:__anon49
FILE_ATTR_COMPRESSED	layout.h	/^	FILE_ATTR_COMPRESSED		= cpu_to_le32(0x00000800),$/;"	e	enum:__anon49
FILE_ATTR_DEVICE	layout.h	/^	FILE_ATTR_DEVICE		= cpu_to_le32(0x00000040),$/;"	e	enum:__anon49
FILE_ATTR_DIRECTORY	layout.h	/^	FILE_ATTR_DIRECTORY		= cpu_to_le32(0x00000010),$/;"	e	enum:__anon49
FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT	layout.h	/^	FILE_ATTR_DUP_FILE_NAME_INDEX_PRESENT	= cpu_to_le32(0x10000000),$/;"	e	enum:__anon49
FILE_ATTR_DUP_VIEW_INDEX_PRESENT	layout.h	/^	FILE_ATTR_DUP_VIEW_INDEX_PRESENT	= cpu_to_le32(0x20000000),$/;"	e	enum:__anon49
FILE_ATTR_ENCRYPTED	layout.h	/^	FILE_ATTR_ENCRYPTED		= cpu_to_le32(0x00004000),$/;"	e	enum:__anon49
FILE_ATTR_FLAGS	layout.h	/^typedef le32 FILE_ATTR_FLAGS;$/;"	t
FILE_ATTR_HIDDEN	layout.h	/^	FILE_ATTR_HIDDEN		= cpu_to_le32(0x00000002),$/;"	e	enum:__anon49
FILE_ATTR_NORMAL	layout.h	/^	FILE_ATTR_NORMAL		= cpu_to_le32(0x00000080),$/;"	e	enum:__anon49
FILE_ATTR_NOT_CONTENT_INDEXED	layout.h	/^	FILE_ATTR_NOT_CONTENT_INDEXED	= cpu_to_le32(0x00002000),$/;"	e	enum:__anon49
FILE_ATTR_OFFLINE	layout.h	/^	FILE_ATTR_OFFLINE		= cpu_to_le32(0x00001000),$/;"	e	enum:__anon49
FILE_ATTR_READONLY	layout.h	/^	FILE_ATTR_READONLY		= cpu_to_le32(0x00000001),$/;"	e	enum:__anon49
FILE_ATTR_REPARSE_POINT	layout.h	/^	FILE_ATTR_REPARSE_POINT		= cpu_to_le32(0x00000400),$/;"	e	enum:__anon49
FILE_ATTR_SPARSE_FILE	layout.h	/^	FILE_ATTR_SPARSE_FILE		= cpu_to_le32(0x00000200),$/;"	e	enum:__anon49
FILE_ATTR_SYSTEM	layout.h	/^	FILE_ATTR_SYSTEM		= cpu_to_le32(0x00000004),$/;"	e	enum:__anon49
FILE_ATTR_TEMPORARY	layout.h	/^	FILE_ATTR_TEMPORARY		= cpu_to_le32(0x00000100),$/;"	e	enum:__anon49
FILE_ATTR_VALID_FLAGS	layout.h	/^	FILE_ATTR_VALID_FLAGS		= cpu_to_le32(0x00007fb7),$/;"	e	enum:__anon49
FILE_ATTR_VALID_SET_FLAGS	layout.h	/^	FILE_ATTR_VALID_SET_FLAGS	= cpu_to_le32(0x000031a7),$/;"	e	enum:__anon49
FILE_AttrDef	layout.h	/^	FILE_AttrDef   = 4,	\/* Array of attribute definitions in data$/;"	e	enum:__anon35
FILE_BadClus	layout.h	/^	FILE_BadClus   = 8,	\/* Contains all bad clusters in the non-resident$/;"	e	enum:__anon35
FILE_Bitmap	layout.h	/^	FILE_Bitmap    = 6,	\/* Allocation bitmap of all clusters (lcns) in$/;"	e	enum:__anon35
FILE_Boot	layout.h	/^	FILE_Boot      = 7,	\/* Boot sector (always at cluster 0) in data$/;"	e	enum:__anon35
FILE_DELETE_CHILD	layout.h	/^	FILE_DELETE_CHILD		= cpu_to_le32(0x00000040),$/;"	e	enum:__anon75
FILE_EXECUTE	layout.h	/^	FILE_EXECUTE			= cpu_to_le32(0x00000020),$/;"	e	enum:__anon75
FILE_Extend	layout.h	/^	FILE_Extend    = 11,	\/* Directory containing other system files (eg.$/;"	e	enum:__anon35
FILE_LIST_DIRECTORY	layout.h	/^	FILE_LIST_DIRECTORY		= cpu_to_le32(0x00000001),$/;"	e	enum:__anon75
FILE_LogFile	layout.h	/^	FILE_LogFile   = 2,	\/* Journalling log in data attribute. *\/$/;"	e	enum:__anon35
FILE_MFT	layout.h	/^	FILE_MFT       = 0,	\/* Master file table (mft). Data attribute$/;"	e	enum:__anon35
FILE_MFTMirr	layout.h	/^	FILE_MFTMirr   = 1,	\/* Mft mirror: copy of first four mft records$/;"	e	enum:__anon35
FILE_NAME_ATTR	layout.h	/^} __attribute__ ((__packed__)) FILE_NAME_ATTR;$/;"	t	typeref:struct:__anon56
FILE_NAME_DOS	layout.h	/^	FILE_NAME_DOS		= 0x02,$/;"	e	enum:__anon55
FILE_NAME_POSIX	layout.h	/^	FILE_NAME_POSIX		= 0x00,$/;"	e	enum:__anon55
FILE_NAME_TYPE_FLAGS	layout.h	/^typedef u8 FILE_NAME_TYPE_FLAGS;$/;"	t
FILE_NAME_WIN32	layout.h	/^	FILE_NAME_WIN32		= 0x01,$/;"	e	enum:__anon55
FILE_NAME_WIN32_AND_DOS	layout.h	/^	FILE_NAME_WIN32_AND_DOS	= 0x03,$/;"	e	enum:__anon55
FILE_READ_ATTRIBUTES	layout.h	/^	FILE_READ_ATTRIBUTES		= cpu_to_le32(0x00000080),$/;"	e	enum:__anon75
FILE_READ_DATA	layout.h	/^	FILE_READ_DATA			= cpu_to_le32(0x00000001),$/;"	e	enum:__anon75
FILE_READ_EA	layout.h	/^	FILE_READ_EA			= cpu_to_le32(0x00000008),$/;"	e	enum:__anon75
FILE_Secure	layout.h	/^	FILE_Secure    = 9,	\/* Shared security descriptors in data attribute$/;"	e	enum:__anon35
FILE_TRAVERSE	layout.h	/^	FILE_TRAVERSE			= cpu_to_le32(0x00000020),$/;"	e	enum:__anon75
FILE_UpCase	layout.h	/^	FILE_UpCase    = 10,	\/* Uppercase equivalents of all 65536 Unicode$/;"	e	enum:__anon35
FILE_Volume	layout.h	/^	FILE_Volume    = 3,	\/* Volume name attribute and volume information$/;"	e	enum:__anon35
FILE_WRITE_ATTRIBUTES	layout.h	/^	FILE_WRITE_ATTRIBUTES		= cpu_to_le32(0x00000100),$/;"	e	enum:__anon75
FILE_WRITE_DATA	layout.h	/^	FILE_WRITE_DATA			= cpu_to_le32(0x00000002),$/;"	e	enum:__anon75
FILE_WRITE_EA	layout.h	/^	FILE_WRITE_EA			= cpu_to_le32(0x00000010),$/;"	e	enum:__anon75
FILE_first_user	layout.h	/^	FILE_first_user = 16,	\/* First user file, used as test limit for$/;"	e	enum:__anon35
FILE_reserved12	layout.h	/^	FILE_reserved12 = 12,	\/* Reserved for future use (records 12-15). *\/$/;"	e	enum:__anon35
FILE_reserved13	layout.h	/^	FILE_reserved13 = 13,$/;"	e	enum:__anon35
FILE_reserved14	layout.h	/^	FILE_reserved14 = 14,$/;"	e	enum:__anon35
FILE_reserved15	layout.h	/^	FILE_reserved15 = 15,$/;"	e	enum:__anon35
FILE_root	layout.h	/^	FILE_root      = 5,	\/* Root directory. *\/$/;"	e	enum:__anon35
FIRST_ZONE	lcnalloc.h	/^	FIRST_ZONE	= 0,	\/* For sanity checking. *\/$/;"	e	enum:__anon23
FS_HAS_SUBTYPE	ntfs_g.h	88;"	d
FS_SAFE	ntfs_g.h	91;"	d
GENERIC_ALL	layout.h	/^	GENERIC_ALL			= cpu_to_le32(0x10000000),$/;"	e	enum:__anon75
GENERIC_EXECUTE	layout.h	/^	GENERIC_EXECUTE			= cpu_to_le32(0x20000000),$/;"	e	enum:__anon75
GENERIC_MAPPING	layout.h	/^} __attribute__ ((__packed__)) GENERIC_MAPPING;$/;"	t	typeref:struct:__anon76
GENERIC_READ	layout.h	/^	GENERIC_READ			= cpu_to_le32(0x80000000),$/;"	e	enum:__anon75
GENERIC_WRITE	layout.h	/^	GENERIC_WRITE			= cpu_to_le32(0x40000000),$/;"	e	enum:__anon75
GUID	layout.h	/^} __attribute__ ((__packed__)) GUID;$/;"	t	typeref:struct:__anon60
I30	dir.c	/^ntfschar I30[5] = { cpu_to_le16('$'), cpu_to_le16('I'),$/;"	v
IGNORE_CASE	types.h	/^	IGNORE_CASE = 1,$/;"	e	enum:__anon20
IGNORE_CASE_BOOL	types.h	/^} IGNORE_CASE_BOOL;$/;"	t	typeref:enum:__anon20
INDEX_ALLOCATION	layout.h	/^typedef INDEX_BLOCK INDEX_ALLOCATION;$/;"	t
INDEX_BLOCK	layout.h	/^} __attribute__ ((__packed__)) INDEX_BLOCK;$/;"	t	typeref:struct:__anon97
INDEX_ENTRY	layout.h	/^} __attribute__ ((__packed__)) INDEX_ENTRY;$/;"	t	typeref:struct:__anon108
INDEX_ENTRY_END	layout.h	/^	INDEX_ENTRY_END  = cpu_to_le16(2), \/* This signifies the last$/;"	e	enum:__anon103
INDEX_ENTRY_FLAGS	layout.h	/^typedef le16 INDEX_ENTRY_FLAGS;$/;"	t
INDEX_ENTRY_HEADER	layout.h	/^} __attribute__ ((__packed__)) INDEX_ENTRY_HEADER;$/;"	t	typeref:struct:__anon104
INDEX_ENTRY_NODE	layout.h	/^	INDEX_ENTRY_NODE = cpu_to_le16(1), \/* This entry contains a$/;"	e	enum:__anon103
INDEX_ENTRY_SPACE_FILLER	layout.h	/^	INDEX_ENTRY_SPACE_FILLER = cpu_to_le16(0xffff), \/* gcc: Force$/;"	e	enum:__anon103
INDEX_HEADER	layout.h	/^} __attribute__ ((__packed__)) INDEX_HEADER;$/;"	t	typeref:struct:__anon95
INDEX_HEADER_FLAGS	layout.h	/^typedef u8 INDEX_HEADER_FLAGS;$/;"	t
INDEX_NODE	layout.h	/^	INDEX_NODE = 1, \/* This node indexes other nodes, i.e. it is not a leaf$/;"	e	enum:__anon94
INDEX_ROOT	layout.h	/^} __attribute__ ((__packed__)) INDEX_ROOT;$/;"	t	typeref:struct:__anon96
INHERITED_ACE	layout.h	/^	INHERITED_ACE			= 0x10,	\/* Win2k only. *\/$/;"	e	enum:__anon73
INHERIT_ONLY_ACE	layout.h	/^	INHERIT_ONLY_ACE		= 0x08,$/;"	e	enum:__anon73
INIT_LOCKDEP	lockdep.h	298;"	d
INIT_LOCKDEP	lockdep.h	330;"	d
IO_REPARSE_TAG_DFS	layout.h	/^	IO_REPARSE_TAG_DFS		= cpu_to_le32(0x68000008),$/;"	e	enum:__anon114
IO_REPARSE_TAG_HSM	layout.h	/^	IO_REPARSE_TAG_HSM		= cpu_to_le32(0xa8000004),$/;"	e	enum:__anon114
IO_REPARSE_TAG_IS_ALIAS	layout.h	/^	IO_REPARSE_TAG_IS_ALIAS		= cpu_to_le32(0x20000000),$/;"	e	enum:__anon114
IO_REPARSE_TAG_IS_HIGH_LATENCY	layout.h	/^	IO_REPARSE_TAG_IS_HIGH_LATENCY	= cpu_to_le32(0x40000000),$/;"	e	enum:__anon114
IO_REPARSE_TAG_IS_MICROSOFT	layout.h	/^	IO_REPARSE_TAG_IS_MICROSOFT	= cpu_to_le32(0x80000000),$/;"	e	enum:__anon114
IO_REPARSE_TAG_MOUNT_POINT	layout.h	/^	IO_REPARSE_TAG_MOUNT_POINT	= cpu_to_le32(0x88000003),$/;"	e	enum:__anon114
IO_REPARSE_TAG_NSS	layout.h	/^	IO_REPARSE_TAG_NSS		= cpu_to_le32(0x68000005),$/;"	e	enum:__anon114
IO_REPARSE_TAG_NSS_RECOVER	layout.h	/^	IO_REPARSE_TAG_NSS_RECOVER	= cpu_to_le32(0x68000006),$/;"	e	enum:__anon114
IO_REPARSE_TAG_RESERVED_ONE	layout.h	/^	IO_REPARSE_TAG_RESERVED_ONE	= cpu_to_le32(0x00000001),$/;"	e	enum:__anon114
IO_REPARSE_TAG_RESERVED_RANGE	layout.h	/^	IO_REPARSE_TAG_RESERVED_RANGE	= cpu_to_le32(0x00000001),$/;"	e	enum:__anon114
IO_REPARSE_TAG_RESERVED_ZERO	layout.h	/^	IO_REPARSE_TAG_RESERVED_ZERO	= cpu_to_le32(0x00000000),$/;"	e	enum:__anon114
IO_REPARSE_TAG_SIS	layout.h	/^	IO_REPARSE_TAG_SIS		= cpu_to_le32(0x68000007),$/;"	e	enum:__anon114
IO_REPARSE_TAG_SYMBOLIC_LINK	layout.h	/^	IO_REPARSE_TAG_SYMBOLIC_LINK	= cpu_to_le32(0xe8000000),$/;"	e	enum:__anon114
IO_REPARSE_TAG_VALID_VALUES	layout.h	/^	IO_REPARSE_TAG_VALID_VALUES	= cpu_to_le32(0xe000ffff),$/;"	e	enum:__anon114
IS_ERR_MREF	layout.h	317;"	d
IS_I_VERSION	ntfs_g.h	289;"	d
LARGE_INDEX	layout.h	/^	LARGE_INDEX = 1, \/* The index is too large to fit in the index root$/;"	e	enum:__anon94
LAST_ZONE	lcnalloc.h	/^	LAST_ZONE	= 1,	\/* For sanity checking. *\/$/;"	e	enum:__anon23
LCN	types.h	/^typedef s64 LCN;$/;"	t
LCN_EIO	runlist.h	/^	LCN_EIO			= -5,$/;"	e	enum:__anon3
LCN_ENOENT	runlist.h	/^	LCN_ENOENT		= -3,$/;"	e	enum:__anon3
LCN_ENOMEM	runlist.h	/^	LCN_ENOMEM		= -4,$/;"	e	enum:__anon3
LCN_HOLE	runlist.h	/^	LCN_HOLE		= -1,	\/* Keep this as highest value or die! *\/$/;"	e	enum:__anon3
LCN_RL_NOT_MAPPED	runlist.h	/^	LCN_RL_NOT_MAPPED	= -2,$/;"	e	enum:__anon3
LCN_SPECIAL_VALUES	runlist.h	/^} LCN_SPECIAL_VALUES;$/;"	t	typeref:enum:__anon3
LEAF_NODE	layout.h	/^	LEAF_NODE  = 0, \/* This is a leaf node, i.e. there are no more nodes$/;"	e	enum:__anon94
LOCKSTAT_POINTS	lockdep.h	43;"	d
LOCK_CONTENDED	lockdep.h	348;"	d
LOCK_CONTENDED	lockdep.h	362;"	d
LOCK_CONTENDED_FLAGS	lockdep.h	374;"	d
LOCK_CONTENDED_FLAGS	lockdep.h	379;"	d
LOGFILE_NO_CLIENT	logfile.h	107;"	d
LOGFILE_NO_CLIENT_CPU	logfile.h	108;"	d
LOGGED_UTILITY_STREAM	layout.h	/^} __attribute__ ((__packed__)) LOGGED_UTILITY_STREAM, EFS_ATTR;$/;"	t	typeref:struct:__anon120
LOG_CLIENT_RECORD	logfile.h	/^} __attribute__ ((__packed__)) LOG_CLIENT_RECORD;$/;"	t	typeref:struct:__anon13
LRU_ACTIVE	ntfs_g.h	190;"	d
LRU_ACTIVE_ANON	ntfs_g.h	/^	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,$/;"	e	enum:lru_list
LRU_ACTIVE_FILE	ntfs_g.h	/^	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,$/;"	e	enum:lru_list
LRU_BASE	ntfs_g.h	189;"	d
LRU_FILE	ntfs_g.h	191;"	d
LRU_INACTIVE_ANON	ntfs_g.h	/^	LRU_INACTIVE_ANON = LRU_BASE,$/;"	e	enum:lru_list
LRU_INACTIVE_FILE	ntfs_g.h	/^	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,$/;"	e	enum:lru_list
LRU_UNEVICTABLE	ntfs_g.h	/^	LRU_UNEVICTABLE,$/;"	e	enum:lru_list
LSN	types.h	/^typedef s64 LSN;$/;"	t
MAXIMUM_ALLOWED	layout.h	/^	MAXIMUM_ALLOWED			= cpu_to_le32(0x02000000),$/;"	e	enum:__anon75
MAXIMUM_FILE_NAME_LENGTH	layout.h	1009;"	d
MAX_ACL_REVISION	layout.h	/^	MAX_ACL_REVISION	= 4,$/;"	e	enum:__anon81
MAX_LOCKDEP_KEYS	lockdep.h	171;"	d
MAX_LOCKDEP_KEYS_BITS	lockdep.h	165;"	d
MAX_LOCKDEP_SUBCLASSES	lockdep.h	28;"	d
MFT_RECORD	layout.h	/^} __attribute__ ((__packed__)) MFT_RECORD;$/;"	t	typeref:struct:__anon37
MFT_RECORD_FLAGS	layout.h	/^typedef le16 MFT_RECORD_FLAGS;$/;"	t
MFT_RECORD_IN_USE	layout.h	/^	MFT_RECORD_IN_USE	= cpu_to_le16(0x0001),$/;"	e	enum:__anon36
MFT_RECORD_IS_DIRECTORY	layout.h	/^	MFT_RECORD_IS_DIRECTORY = cpu_to_le16(0x0002),$/;"	e	enum:__anon36
MFT_RECORD_OLD	layout.h	/^} __attribute__ ((__packed__)) MFT_RECORD_OLD;$/;"	t	typeref:struct:__anon38
MFT_REF	layout.h	/^typedef u64 MFT_REF;$/;"	t
MFT_REF_MASK_CPU	layout.h	302;"	d
MFT_REF_MASK_LE	layout.h	303;"	d
MFT_ZONE	lcnalloc.h	/^	MFT_ZONE	= 0,	\/* Allocate from $MFT zone. *\/$/;"	e	enum:__anon23
MIN_ACL_REVISION	layout.h	/^	MIN_ACL_REVISION	= 2,$/;"	e	enum:__anon81
MK_LE_MREF	layout.h	310;"	d
MK_MREF	layout.h	308;"	d
MREF	layout.h	312;"	d
MREF_ERR	layout.h	319;"	d
MREF_LE	layout.h	314;"	d
MSEQNO	layout.h	313;"	d
MSEQNO_LE	layout.h	315;"	d
MS_I_VERSION	ntfs_g.h	290;"	d
MaxLogFileSize	logfile.h	60;"	d
MinLogRecordPages	logfile.h	62;"	d
NEED_EA	layout.h	/^	NEED_EA	= 0x80		\/* If set the file to which the EA belongs$/;"	e	enum:__anon117
NINO_FNS	inode.h	181;"	d
NI_Attr	inode.h	/^	NI_Attr,		\/* 1: Fake inode for attribute i\/o.$/;"	e	enum:__anon28
NI_AttrList	inode.h	/^	NI_AttrList,		\/* 1: Mft record contains an attribute list. *\/$/;"	e	enum:__anon28
NI_AttrListNonResident	inode.h	/^	NI_AttrListNonResident,	\/* 1: Attribute list is non-resident. Implies$/;"	e	enum:__anon28
NI_Compressed	inode.h	/^	NI_Compressed,		\/* 1: Unnamed data attr is compressed (f).$/;"	e	enum:__anon28
NI_Dirty	inode.h	/^	NI_Dirty,		\/* 1: Mft record needs to be written to disk. *\/$/;"	e	enum:__anon28
NI_Encrypted	inode.h	/^	NI_Encrypted,		\/* 1: Unnamed data attr is encrypted (f).$/;"	e	enum:__anon28
NI_IndexAllocPresent	inode.h	/^	NI_IndexAllocPresent = NI_NonResident,	\/* 1: $I30 index alloc attr is$/;"	e	enum:__anon28
NI_MstProtected	inode.h	/^	NI_MstProtected,	\/* 1: Attribute is protected by MST fixups.$/;"	e	enum:__anon28
NI_NonResident	inode.h	/^	NI_NonResident,		\/* 1: Unnamed data attr is non-resident (f).$/;"	e	enum:__anon28
NI_Sparse	inode.h	/^	NI_Sparse,		\/* 1: Unnamed data attr is sparse (f).$/;"	e	enum:__anon28
NI_SparseDisabled	inode.h	/^	NI_SparseDisabled,	\/* 1: May not create sparse regions. *\/$/;"	e	enum:__anon28
NI_TruncateFailed	inode.h	/^	NI_TruncateFailed,	\/* 1: Last ntfs_truncate() call failed. *\/$/;"	e	enum:__anon28
NODE_MASK	layout.h	/^	NODE_MASK  = 1, \/* Mask for accessing the *_NODE bits. *\/$/;"	e	enum:__anon94
NO_PROPAGATE_INHERIT_ACE	layout.h	/^	NO_PROPAGATE_INHERIT_ACE	= 0x04,$/;"	e	enum:__anon73
NR_LRU_LISTS	ntfs_g.h	/^	NR_LRU_LISTS$/;"	e	enum:lru_list
NTFS_BLOCK_SIZE	ntfs.h	/^	NTFS_BLOCK_SIZE		= 512,$/;"	e	enum:__anon16
NTFS_BLOCK_SIZE_BITS	ntfs.h	/^	NTFS_BLOCK_SIZE_BITS	= 9,$/;"	e	enum:__anon16
NTFS_BOOT_SECTOR	layout.h	/^} __attribute__ ((__packed__)) NTFS_BOOT_SECTOR;$/;"	t	typeref:struct:__anon32
NTFS_CLUSTER_ALLOCATION_ZONES	lcnalloc.h	/^} NTFS_CLUSTER_ALLOCATION_ZONES;$/;"	t	typeref:enum:__anon23
NTFS_CONSTANTS	ntfs.h	/^} NTFS_CONSTANTS;$/;"	t	typeref:enum:__anon16
NTFS_GETOPT	super.c	122;"	d	file:
NTFS_GETOPT	super.c	229;"	d	file:
NTFS_GETOPT_BOOL	super.c	138;"	d	file:
NTFS_GETOPT_BOOL	super.c	228;"	d	file:
NTFS_GETOPT_OCTAL	super.c	130;"	d	file:
NTFS_GETOPT_OPTIONS_ARRAY	super.c	145;"	d	file:
NTFS_GETOPT_OPTIONS_ARRAY	super.c	227;"	d	file:
NTFS_GETOPT_WITH_DEFAULT	super.c	112;"	d	file:
NTFS_GETOPT_WITH_DEFAULT	super.c	230;"	d	file:
NTFS_HIBERFIL_HEADER_SIZE	super.c	1210;"	d	file:
NTFS_I	inode.h	/^static inline ntfs_inode *NTFS_I(struct inode *inode)$/;"	f
NTFS_MAX_ATTR_NAME_LEN	ntfs.h	/^	NTFS_MAX_ATTR_NAME_LEN	= 255,$/;"	e	enum:__anon16
NTFS_MAX_CB_SIZE	compress.c	/^	NTFS_MAX_CB_SIZE	= 64 * 1024,$/;"	e	enum:__anon19	file:
NTFS_MAX_CLUSTER_SIZE	ntfs.h	/^	NTFS_MAX_CLUSTER_SIZE	= 64 * 1024,	\/* 64kiB *\/$/;"	e	enum:__anon16
NTFS_MAX_NAME_LEN	ntfs.h	/^	NTFS_MAX_NAME_LEN	= 255,$/;"	e	enum:__anon16
NTFS_MAX_PAGES_PER_CLUSTER	ntfs.h	/^	NTFS_MAX_PAGES_PER_CLUSTER = NTFS_MAX_CLUSTER_SIZE \/ PAGE_CACHE_SIZE,$/;"	e	enum:__anon16
NTFS_PHRASE_TOKEN	compress.c	/^	NTFS_PHRASE_TOKEN	=	1,$/;"	e	enum:__anon19	file:
NTFS_RECORD	layout.h	/^} __attribute__ ((__packed__)) NTFS_RECORD;$/;"	t	typeref:struct:__anon34
NTFS_RECORD_TYPE	layout.h	/^typedef le32 NTFS_RECORD_TYPE;$/;"	t
NTFS_SB	ntfs.h	/^static inline ntfs_volume *NTFS_SB(struct super_block *sb)$/;"	f
NTFS_SB_IS_COMPRESSED	compress.c	/^	NTFS_SB_IS_COMPRESSED	=	0x8000,$/;"	e	enum:__anon19	file:
NTFS_SB_MAGIC	ntfs.h	/^	NTFS_SB_MAGIC		= 0x5346544e,	\/* 'NTFS' *\/$/;"	e	enum:__anon16
NTFS_SB_SIZE	compress.c	/^	NTFS_SB_SIZE		=	0x1000,$/;"	e	enum:__anon19	file:
NTFS_SB_SIZE_MASK	compress.c	/^	NTFS_SB_SIZE_MASK	=	0x0fff,$/;"	e	enum:__anon19	file:
NTFS_SYMBOL_TOKEN	compress.c	/^	NTFS_SYMBOL_TOKEN	=	0,$/;"	e	enum:__anon19	file:
NTFS_SYSTEM_FILES	layout.h	/^} NTFS_SYSTEM_FILES;$/;"	t	typeref:enum:__anon35
NTFS_TIME_OFFSET	namei.c	657;"	d	file:
NTFS_TIME_OFFSET	time.h	30;"	d
NTFS_TOKEN_MASK	compress.c	/^	NTFS_TOKEN_MASK		=	1,$/;"	e	enum:__anon19	file:
NTFS_VERSION	super.c	/^MODULE_VERSION(NTFS_VERSION);$/;"	v
NV_CaseSensitive	volume.h	/^	NV_CaseSensitive,	\/* 1: Treat file names as case sensitive and$/;"	e	enum:__anon5
NV_Errors	volume.h	/^	NV_Errors,		\/* 1: Volume has errors, prevent remount rw. *\/$/;"	e	enum:__anon5
NV_LogFileEmpty	volume.h	/^	NV_LogFileEmpty,	\/* 1: $LogFile journal is empty. *\/$/;"	e	enum:__anon5
NV_QuotaOutOfDate	volume.h	/^	NV_QuotaOutOfDate,	\/* 1: $Quota is out of date. *\/$/;"	e	enum:__anon5
NV_ShowSystemFiles	volume.h	/^	NV_ShowSystemFiles,	\/* 1: Return system files in ntfs_readdir(). *\/$/;"	e	enum:__anon5
NV_SparseEnabled	volume.h	/^	NV_SparseEnabled,	\/* 1: May create sparse files. *\/$/;"	e	enum:__anon5
NV_UsnJrnlStamped	volume.h	/^	NV_UsnJrnlStamped,	\/* 1: $UsnJrnl has been stamped. *\/$/;"	e	enum:__anon5
OBJECT_ACE_FLAGS	layout.h	/^typedef le32 OBJECT_ACE_FLAGS;$/;"	t
OBJECT_ID_ATTR	layout.h	/^} __attribute__ ((__packed__)) OBJECT_ID_ATTR;$/;"	t	typeref:struct:__anon64
OBJECT_INHERIT_ACE	layout.h	/^	OBJECT_INHERIT_ACE		= 0x01,$/;"	e	enum:__anon73
OBJ_ID_INDEX_DATA	layout.h	/^} __attribute__ ((__packed__)) OBJ_ID_INDEX_DATA;$/;"	t	typeref:struct:__anon61
ON_ERRORS_ACTIONS	super.c	/^} ON_ERRORS_ACTIONS;$/;"	t	typeref:enum:__anon22	file:
ON_ERRORS_CONTINUE	super.c	/^	ON_ERRORS_CONTINUE		= 0x04,$/;"	e	enum:__anon22	file:
ON_ERRORS_PANIC	super.c	/^	ON_ERRORS_PANIC			= 0x01,$/;"	e	enum:__anon22	file:
ON_ERRORS_RECOVER	super.c	/^	ON_ERRORS_RECOVER		= 0x10,$/;"	e	enum:__anon22	file:
ON_ERRORS_REMOUNT_RO	super.c	/^	ON_ERRORS_REMOUNT_RO		= 0x02,$/;"	e	enum:__anon22	file:
PROPERTY_SET	layout.h	/^} __attribute__ ((__packed__)) PROPERTY_SET;$/;"	t	typeref:struct:__anon119
QUOTA_CONTROL_ENTRY	layout.h	/^} __attribute__ ((__packed__)) QUOTA_CONTROL_ENTRY;$/;"	t	typeref:struct:__anon100
QUOTA_CONTROL_ENTRY_CONSTANTS	layout.h	/^} QUOTA_CONTROL_ENTRY_CONSTANTS;$/;"	t	typeref:enum:__anon102
QUOTA_DEFAULTS_ID	layout.h	/^	QUOTA_DEFAULTS_ID	= cpu_to_le32(0x00000001),$/;"	e	enum:__anon101
QUOTA_FIRST_USER_ID	layout.h	/^	QUOTA_FIRST_USER_ID	= cpu_to_le32(0x00000100),$/;"	e	enum:__anon101
QUOTA_FLAGS	layout.h	/^typedef le32 QUOTA_FLAGS;$/;"	t
QUOTA_FLAG_CORRUPT	layout.h	/^	QUOTA_FLAG_CORRUPT		= cpu_to_le32(0x00000400),$/;"	e	enum:__anon99
QUOTA_FLAG_DEFAULT_LIMITS	layout.h	/^	QUOTA_FLAG_DEFAULT_LIMITS	= cpu_to_le32(0x00000001),$/;"	e	enum:__anon99
QUOTA_FLAG_ENFORCEMENT_ENABLED	layout.h	/^	QUOTA_FLAG_ENFORCEMENT_ENABLED	= cpu_to_le32(0x00000020),$/;"	e	enum:__anon99
QUOTA_FLAG_ID_DELETED	layout.h	/^	QUOTA_FLAG_ID_DELETED		= cpu_to_le32(0x00000004),$/;"	e	enum:__anon99
QUOTA_FLAG_LIMIT_REACHED	layout.h	/^	QUOTA_FLAG_LIMIT_REACHED	= cpu_to_le32(0x00000002),$/;"	e	enum:__anon99
QUOTA_FLAG_LOG_LIMIT	layout.h	/^	QUOTA_FLAG_LOG_LIMIT		= cpu_to_le32(0x00000100),$/;"	e	enum:__anon99
QUOTA_FLAG_LOG_THRESHOLD	layout.h	/^	QUOTA_FLAG_LOG_THRESHOLD	= cpu_to_le32(0x00000080),$/;"	e	enum:__anon99
QUOTA_FLAG_OUT_OF_DATE	layout.h	/^	QUOTA_FLAG_OUT_OF_DATE		= cpu_to_le32(0x00000200),$/;"	e	enum:__anon99
QUOTA_FLAG_PENDING_DELETES	layout.h	/^	QUOTA_FLAG_PENDING_DELETES	= cpu_to_le32(0x00000800),$/;"	e	enum:__anon99
QUOTA_FLAG_TRACKING_ENABLED	layout.h	/^	QUOTA_FLAG_TRACKING_ENABLED	= cpu_to_le32(0x00000010),$/;"	e	enum:__anon99
QUOTA_FLAG_TRACKING_REQUESTED	layout.h	/^	QUOTA_FLAG_TRACKING_REQUESTED	= cpu_to_le32(0x00000040),$/;"	e	enum:__anon99
QUOTA_FLAG_USER_MASK	layout.h	/^	QUOTA_FLAG_USER_MASK		= cpu_to_le32(0x00000007),$/;"	e	enum:__anon99
QUOTA_INVALID_ID	layout.h	/^	QUOTA_INVALID_ID	= cpu_to_le32(0x00000000),$/;"	e	enum:__anon101
QUOTA_VERSION	layout.h	/^	QUOTA_VERSION	= 2,$/;"	e	enum:__anon102
READ_CONTROL	layout.h	/^	READ_CONTROL			= cpu_to_le32(0x00020000),$/;"	e	enum:__anon75
RELATIVE_IDENTIFIERS	layout.h	/^} RELATIVE_IDENTIFIERS;$/;"	t	typeref:enum:__anon67
REPARSE_INDEX_KEY	layout.h	/^} __attribute__ ((__packed__)) REPARSE_INDEX_KEY;$/;"	t	typeref:struct:__anon98
REPARSE_POINT	layout.h	/^} __attribute__ ((__packed__)) REPARSE_POINT;$/;"	t	typeref:struct:__anon115
RESIDENT_ATTR_FLAGS	layout.h	/^typedef u8 RESIDENT_ATTR_FLAGS;$/;"	t
RESIDENT_ATTR_IS_INDEXED	layout.h	/^	RESIDENT_ATTR_IS_INDEXED = 0x01, \/* Attribute is referenced in an index$/;"	e	enum:__anon44
RESTART_AREA	logfile.h	/^} __attribute__ ((__packed__)) RESTART_AREA;$/;"	t	typeref:struct:__anon12
RESTART_AREA_FLAGS	logfile.h	/^typedef le16 RESTART_AREA_FLAGS;$/;"	t
RESTART_PAGE_HEADER	logfile.h	/^} __attribute__ ((__packed__)) RESTART_PAGE_HEADER;$/;"	t	typeref:struct:__anon10
RESTART_SPACE_FILLER	logfile.h	/^	RESTART_SPACE_FILLER	= cpu_to_le16(0xffff), \/* gcc: Force enum bit width to 16. *\/$/;"	e	enum:__anon11
RESTART_VOLUME_IS_CLEAN	logfile.h	/^	RESTART_VOLUME_IS_CLEAN	= cpu_to_le16(0x0002),$/;"	e	enum:__anon11
SDH_INDEX_KEY	layout.h	/^} __attribute__ ((__packed__)) SDH_INDEX_KEY;$/;"	t	typeref:struct:__anon89
SDS_ENTRY	layout.h	/^} __attribute__ ((__packed__)) SDS_ENTRY;$/;"	t	typeref:struct:__anon87
SECURITY_ANONYMOUS_LOGON_RID	layout.h	/^	SECURITY_ANONYMOUS_LOGON_RID	  = 7,$/;"	e	enum:__anon67
SECURITY_AUTHENTICATED_USER_RID	layout.h	/^	SECURITY_AUTHENTICATED_USER_RID	  = 0xb,$/;"	e	enum:__anon67
SECURITY_BATCH_RID	layout.h	/^	SECURITY_BATCH_RID		  = 3,$/;"	e	enum:__anon67
SECURITY_BUILTIN_DOMAIN_RID	layout.h	/^	SECURITY_BUILTIN_DOMAIN_RID	  = 0x20,$/;"	e	enum:__anon67
SECURITY_CREATOR_GROUP_RID	layout.h	/^	SECURITY_CREATOR_GROUP_RID	  = 1,	\/* S-1-3 *\/$/;"	e	enum:__anon67
SECURITY_CREATOR_GROUP_SERVER_RID	layout.h	/^	SECURITY_CREATOR_GROUP_SERVER_RID = 3,	\/* S-1-3 *\/$/;"	e	enum:__anon67
SECURITY_CREATOR_OWNER_RID	layout.h	/^	SECURITY_CREATOR_OWNER_RID	  = 0,	\/* S-1-3 *\/$/;"	e	enum:__anon67
SECURITY_CREATOR_OWNER_SERVER_RID	layout.h	/^	SECURITY_CREATOR_OWNER_SERVER_RID = 2,	\/* S-1-3 *\/$/;"	e	enum:__anon67
SECURITY_DESCRIPTOR	layout.h	/^} __attribute__ ((__packed__)) SECURITY_DESCRIPTOR;$/;"	t	typeref:struct:__anon84
SECURITY_DESCRIPTOR_ATTR	layout.h	/^typedef SECURITY_DESCRIPTOR_RELATIVE SECURITY_DESCRIPTOR_ATTR;$/;"	t
SECURITY_DESCRIPTOR_CONSTANTS	layout.h	/^} SECURITY_DESCRIPTOR_CONSTANTS;$/;"	t	typeref:enum:__anon85
SECURITY_DESCRIPTOR_CONTROL	layout.h	/^typedef le16 SECURITY_DESCRIPTOR_CONTROL;$/;"	t
SECURITY_DESCRIPTOR_HEADER	layout.h	/^} __attribute__ ((__packed__)) SECURITY_DESCRIPTOR_HEADER;$/;"	t	typeref:struct:__anon86
SECURITY_DESCRIPTOR_MIN_LENGTH	layout.h	/^	SECURITY_DESCRIPTOR_MIN_LENGTH	= sizeof(SECURITY_DESCRIPTOR),$/;"	e	enum:__anon85
SECURITY_DESCRIPTOR_RELATIVE	layout.h	/^} __attribute__ ((__packed__)) SECURITY_DESCRIPTOR_RELATIVE;$/;"	t	typeref:struct:__anon83
SECURITY_DESCRIPTOR_REVISION	layout.h	/^	SECURITY_DESCRIPTOR_REVISION	= 1,$/;"	e	enum:__anon85
SECURITY_DESCRIPTOR_REVISION1	layout.h	/^	SECURITY_DESCRIPTOR_REVISION1	= 1,$/;"	e	enum:__anon85
SECURITY_DIALUP_RID	layout.h	/^	SECURITY_DIALUP_RID		  = 1,$/;"	e	enum:__anon67
SECURITY_ENTERPRISE_CONTROLLERS_RID	layout.h	/^	SECURITY_ENTERPRISE_CONTROLLERS_RID=9,$/;"	e	enum:__anon67
SECURITY_INTERACTIVE_RID	layout.h	/^	SECURITY_INTERACTIVE_RID	  = 4,$/;"	e	enum:__anon67
SECURITY_LOCAL_RID	layout.h	/^	SECURITY_LOCAL_RID		  = 0,	\/* S-1-2 *\/$/;"	e	enum:__anon67
SECURITY_LOCAL_SYSTEM_RID	layout.h	/^	SECURITY_LOCAL_SYSTEM_RID	  = 0x12,$/;"	e	enum:__anon67
SECURITY_LOGON_IDS_RID	layout.h	/^	SECURITY_LOGON_IDS_RID		  = 5,$/;"	e	enum:__anon67
SECURITY_LOGON_IDS_RID_COUNT	layout.h	/^	SECURITY_LOGON_IDS_RID_COUNT	  = 3,$/;"	e	enum:__anon67
SECURITY_NETWORK_RID	layout.h	/^	SECURITY_NETWORK_RID		  = 2,$/;"	e	enum:__anon67
SECURITY_NT_NON_UNIQUE	layout.h	/^	SECURITY_NT_NON_UNIQUE		  = 0x15,$/;"	e	enum:__anon67
SECURITY_NULL_RID	layout.h	/^	SECURITY_NULL_RID		  = 0,	\/* S-1-0 *\/$/;"	e	enum:__anon67
SECURITY_PRINCIPAL_SELF_RID	layout.h	/^	SECURITY_PRINCIPAL_SELF_RID	  = 0xa,$/;"	e	enum:__anon67
SECURITY_PROXY_RID	layout.h	/^	SECURITY_PROXY_RID		  = 8,$/;"	e	enum:__anon67
SECURITY_RESTRICTED_CODE_RID	layout.h	/^	SECURITY_RESTRICTED_CODE_RID	  = 0xc,$/;"	e	enum:__anon67
SECURITY_SERVER_LOGON_RID	layout.h	/^	SECURITY_SERVER_LOGON_RID	  = 9,$/;"	e	enum:__anon67
SECURITY_SERVICE_RID	layout.h	/^	SECURITY_SERVICE_RID		  = 6,$/;"	e	enum:__anon67
SECURITY_TERMINAL_SERVER_RID	layout.h	/^	SECURITY_TERMINAL_SERVER_RID	  = 0xd,$/;"	e	enum:__anon67
SECURITY_WORLD_RID	layout.h	/^	SECURITY_WORLD_RID		  = 0,	\/* S-1-1 *\/$/;"	e	enum:__anon67
SE_DACL_AUTO_INHERITED	layout.h	/^	SE_DACL_AUTO_INHERITED		= cpu_to_le16(0x0400),$/;"	e	enum:__anon82
SE_DACL_AUTO_INHERIT_REQ	layout.h	/^	SE_DACL_AUTO_INHERIT_REQ	= cpu_to_le16(0x0100),$/;"	e	enum:__anon82
SE_DACL_DEFAULTED	layout.h	/^	SE_DACL_DEFAULTED		= cpu_to_le16(0x0008),$/;"	e	enum:__anon82
SE_DACL_PRESENT	layout.h	/^	SE_DACL_PRESENT			= cpu_to_le16(0x0004),$/;"	e	enum:__anon82
SE_DACL_PROTECTED	layout.h	/^	SE_DACL_PROTECTED		= cpu_to_le16(0x1000),$/;"	e	enum:__anon82
SE_GROUP_DEFAULTED	layout.h	/^	SE_GROUP_DEFAULTED		= cpu_to_le16(0x0002),$/;"	e	enum:__anon82
SE_OWNER_DEFAULTED	layout.h	/^	SE_OWNER_DEFAULTED		= cpu_to_le16(0x0001),$/;"	e	enum:__anon82
SE_RM_CONTROL_VALID	layout.h	/^	SE_RM_CONTROL_VALID		= cpu_to_le16(0x4000),$/;"	e	enum:__anon82
SE_SACL_AUTO_INHERITED	layout.h	/^	SE_SACL_AUTO_INHERITED		= cpu_to_le16(0x0800),$/;"	e	enum:__anon82
SE_SACL_AUTO_INHERIT_REQ	layout.h	/^	SE_SACL_AUTO_INHERIT_REQ	= cpu_to_le16(0x0200),$/;"	e	enum:__anon82
SE_SACL_DEFAULTED	layout.h	/^	SE_SACL_DEFAULTED		= cpu_to_le16(0x0020),$/;"	e	enum:__anon82
SE_SACL_PRESENT	layout.h	/^	SE_SACL_PRESENT			= cpu_to_le16(0x0010),$/;"	e	enum:__anon82
SE_SACL_PROTECTED	layout.h	/^	SE_SACL_PROTECTED		= cpu_to_le16(0x2000),$/;"	e	enum:__anon82
SE_SELF_RELATIVE	layout.h	/^	SE_SELF_RELATIVE		= cpu_to_le16(0x8000)$/;"	e	enum:__anon82
SID	layout.h	/^} __attribute__ ((__packed__)) SID;$/;"	t	typeref:struct:__anon70
SID_CONSTANTS	layout.h	/^} SID_CONSTANTS;$/;"	t	typeref:enum:__anon71
SID_IDENTIFIER_AUTHORITY	layout.h	/^} __attribute__ ((__packed__)) SID_IDENTIFIER_AUTHORITY;$/;"	t	typeref:union:__anon68
SID_MAX_SUB_AUTHORITIES	layout.h	/^	SID_MAX_SUB_AUTHORITIES		= 15,	\/* Maximum number of those. *\/$/;"	e	enum:__anon71
SID_RECOMMENDED_SUB_AUTHORITIES	layout.h	/^	SID_RECOMMENDED_SUB_AUTHORITIES	=  1,	\/* Will change to around 6 in$/;"	e	enum:__anon71
SID_REVISION	layout.h	/^	SID_REVISION			=  1,	\/* Current revision level. *\/$/;"	e	enum:__anon71
SII_INDEX_KEY	layout.h	/^} __attribute__ ((__packed__)) SII_INDEX_KEY;$/;"	t	typeref:struct:__anon88
SINGLE_DEPTH_NESTING	lockdep.h	413;"	d
SMALL_INDEX	layout.h	/^	SMALL_INDEX = 0, \/* The index is small enough to fit inside the index$/;"	e	enum:__anon94
STANDARD_INFORMATION	layout.h	/^} __attribute__ ((__packed__)) STANDARD_INFORMATION;$/;"	t	typeref:struct:__anon50
STANDARD_RIGHTS_ALL	layout.h	/^	STANDARD_RIGHTS_ALL		= cpu_to_le32(0x001f0000),$/;"	e	enum:__anon75
STANDARD_RIGHTS_EXECUTE	layout.h	/^	STANDARD_RIGHTS_EXECUTE		= cpu_to_le32(0x00020000),$/;"	e	enum:__anon75
STANDARD_RIGHTS_READ	layout.h	/^	STANDARD_RIGHTS_READ		= cpu_to_le32(0x00020000),$/;"	e	enum:__anon75
STANDARD_RIGHTS_REQUIRED	layout.h	/^	STANDARD_RIGHTS_REQUIRED	= cpu_to_le32(0x000f0000),$/;"	e	enum:__anon75
STANDARD_RIGHTS_WRITE	layout.h	/^	STANDARD_RIGHTS_WRITE		= cpu_to_le32(0x00020000),$/;"	e	enum:__anon75
STATIC_LOCKDEP_MAP_INIT	lockdep.h	243;"	d
STATUS_ERROR	namei.c	281;"	d	file:
STATUS_OK	namei.c	280;"	d	file:
SUCCESSFUL_ACCESS_ACE_FLAG	layout.h	/^	SUCCESSFUL_ACCESS_ACE_FLAG	= 0x40,$/;"	e	enum:__anon73
SYNCHRONIZE	layout.h	/^	SYNCHRONIZE			= cpu_to_le32(0x00100000),$/;"	e	enum:__anon75
SYSTEM_ALARM_ACE	layout.h	/^			       SYSTEM_AUDIT_ACE, SYSTEM_ALARM_ACE;$/;"	t	typeref:struct:__anon77
SYSTEM_ALARM_ACE_TYPE	layout.h	/^	SYSTEM_ALARM_ACE_TYPE		= 3, \/* Not implemented as of Win2k. *\/$/;"	e	enum:__anon72
SYSTEM_ALARM_OBJECT_ACE	layout.h	/^			       SYSTEM_ALARM_OBJECT_ACE;$/;"	t	typeref:struct:__anon79
SYSTEM_ALARM_OBJECT_ACE_TYPE	layout.h	/^	SYSTEM_ALARM_OBJECT_ACE_TYPE	= 8,$/;"	e	enum:__anon72
SYSTEM_AUDIT_ACE	layout.h	/^			       SYSTEM_AUDIT_ACE, SYSTEM_ALARM_ACE;$/;"	t	typeref:struct:__anon77
SYSTEM_AUDIT_ACE_TYPE	layout.h	/^	SYSTEM_AUDIT_ACE_TYPE		= 2,$/;"	e	enum:__anon72
SYSTEM_AUDIT_OBJECT_ACE	layout.h	/^			       SYSTEM_AUDIT_OBJECT_ACE,$/;"	t	typeref:struct:__anon79
SYSTEM_AUDIT_OBJECT_ACE_TYPE	layout.h	/^	SYSTEM_AUDIT_OBJECT_ACE_TYPE	= 7,$/;"	e	enum:__anon72
TAS_NINO_FNS	inode.h	198;"	d
UCHAR_T_SIZE_BITS	types.h	37;"	d
USN	types.h	/^typedef s64 USN;$/;"	t
USN_HEADER	usnjrnl.h	/^} __attribute__ ((__packed__)) USN_HEADER;$/;"	t	typeref:struct:__anon6
USN_REASON_BASIC_INFO_CHANGE	usnjrnl.h	/^	USN_REASON_BASIC_INFO_CHANGE	= cpu_to_le32(0x00008000),$/;"	e	enum:__anon7
USN_REASON_CLOSE	usnjrnl.h	/^	USN_REASON_CLOSE		= cpu_to_le32(0x80000000),$/;"	e	enum:__anon7
USN_REASON_COMPRESSION_CHANGE	usnjrnl.h	/^	USN_REASON_COMPRESSION_CHANGE	= cpu_to_le32(0x00020000),$/;"	e	enum:__anon7
USN_REASON_DATA_EXTEND	usnjrnl.h	/^	USN_REASON_DATA_EXTEND		= cpu_to_le32(0x00000002),$/;"	e	enum:__anon7
USN_REASON_DATA_OVERWRITE	usnjrnl.h	/^	USN_REASON_DATA_OVERWRITE	= cpu_to_le32(0x00000001),$/;"	e	enum:__anon7
USN_REASON_DATA_TRUNCATION	usnjrnl.h	/^	USN_REASON_DATA_TRUNCATION	= cpu_to_le32(0x00000004),$/;"	e	enum:__anon7
USN_REASON_EA_CHANGE	usnjrnl.h	/^	USN_REASON_EA_CHANGE		= cpu_to_le32(0x00000400),$/;"	e	enum:__anon7
USN_REASON_ENCRYPTION_CHANGE	usnjrnl.h	/^	USN_REASON_ENCRYPTION_CHANGE	= cpu_to_le32(0x00040000),$/;"	e	enum:__anon7
USN_REASON_FILE_CREATE	usnjrnl.h	/^	USN_REASON_FILE_CREATE		= cpu_to_le32(0x00000100),$/;"	e	enum:__anon7
USN_REASON_FILE_DELETE	usnjrnl.h	/^	USN_REASON_FILE_DELETE		= cpu_to_le32(0x00000200),$/;"	e	enum:__anon7
USN_REASON_FLAGS	usnjrnl.h	/^typedef le32 USN_REASON_FLAGS;$/;"	t
USN_REASON_HARD_LINK_CHANGE	usnjrnl.h	/^	USN_REASON_HARD_LINK_CHANGE	= cpu_to_le32(0x00010000),$/;"	e	enum:__anon7
USN_REASON_INDEXABLE_CHANGE	usnjrnl.h	/^	USN_REASON_INDEXABLE_CHANGE	= cpu_to_le32(0x00004000),$/;"	e	enum:__anon7
USN_REASON_NAMED_DATA_EXTEND	usnjrnl.h	/^	USN_REASON_NAMED_DATA_EXTEND	= cpu_to_le32(0x00000020),$/;"	e	enum:__anon7
USN_REASON_NAMED_DATA_OVERWRITE	usnjrnl.h	/^	USN_REASON_NAMED_DATA_OVERWRITE	= cpu_to_le32(0x00000010),$/;"	e	enum:__anon7
USN_REASON_NAMED_DATA_TRUNCATION	usnjrnl.h	/^	USN_REASON_NAMED_DATA_TRUNCATION= cpu_to_le32(0x00000040),$/;"	e	enum:__anon7
USN_REASON_OBJECT_ID_CHANGE	usnjrnl.h	/^	USN_REASON_OBJECT_ID_CHANGE	= cpu_to_le32(0x00080000),$/;"	e	enum:__anon7
USN_REASON_RENAME_NEW_NAME	usnjrnl.h	/^	USN_REASON_RENAME_NEW_NAME	= cpu_to_le32(0x00002000),$/;"	e	enum:__anon7
USN_REASON_RENAME_OLD_NAME	usnjrnl.h	/^	USN_REASON_RENAME_OLD_NAME	= cpu_to_le32(0x00001000),$/;"	e	enum:__anon7
USN_REASON_REPARSE_POINT_CHANGE	usnjrnl.h	/^	USN_REASON_REPARSE_POINT_CHANGE	= cpu_to_le32(0x00100000),$/;"	e	enum:__anon7
USN_REASON_SECURITY_CHANGE	usnjrnl.h	/^	USN_REASON_SECURITY_CHANGE	= cpu_to_le32(0x00000800),$/;"	e	enum:__anon7
USN_REASON_STREAM_CHANGE	usnjrnl.h	/^	USN_REASON_STREAM_CHANGE	= cpu_to_le32(0x00200000),$/;"	e	enum:__anon7
USN_RECORD	usnjrnl.h	/^} __attribute__ ((__packed__)) USN_RECORD;$/;"	t	typeref:struct:__anon9
USN_SOURCE_AUXILIARY_DATA	usnjrnl.h	/^	USN_SOURCE_AUXILIARY_DATA	  = cpu_to_le32(0x00000002),$/;"	e	enum:__anon8
USN_SOURCE_DATA_MANAGEMENT	usnjrnl.h	/^	USN_SOURCE_DATA_MANAGEMENT	  = cpu_to_le32(0x00000001),$/;"	e	enum:__anon8
USN_SOURCE_INFO_FLAGS	usnjrnl.h	/^typedef le32 USN_SOURCE_INFO_FLAGS;$/;"	t
USN_SOURCE_REPLICATION_MANAGEMENT	usnjrnl.h	/^	USN_SOURCE_REPLICATION_MANAGEMENT = cpu_to_le32(0x00000004),$/;"	e	enum:__anon8
UsnJrnlMajorVer	usnjrnl.h	93;"	d
UsnJrnlMinorVer	usnjrnl.h	94;"	d
VALID_INHERIT_FLAGS	layout.h	/^	VALID_INHERIT_FLAGS		= 0x1f,$/;"	e	enum:__anon73
VCN	types.h	/^typedef s64 VCN;$/;"	t
VFS_I	inode.h	/^static inline struct inode *VFS_I(ntfs_inode *ni)$/;"	f
VM_BUG_ON	ntfs_g.h	18;"	d
VM_BUG_ON	ntfs_g.h	20;"	d
VOLUME_CHKDSK_UNDERWAY	layout.h	/^	VOLUME_CHKDSK_UNDERWAY		= cpu_to_le16(0x4000),$/;"	e	enum:__anon91
VOLUME_DELETE_USN_UNDERWAY	layout.h	/^	VOLUME_DELETE_USN_UNDERWAY	= cpu_to_le16(0x0010),$/;"	e	enum:__anon91
VOLUME_FLAGS	layout.h	/^typedef le16 VOLUME_FLAGS;$/;"	t
VOLUME_FLAGS_MASK	layout.h	/^	VOLUME_FLAGS_MASK		= cpu_to_le16(0xc03f),$/;"	e	enum:__anon91
VOLUME_INFORMATION	layout.h	/^} __attribute__ ((__packed__)) VOLUME_INFORMATION;$/;"	t	typeref:struct:__anon92
VOLUME_IS_DIRTY	layout.h	/^	VOLUME_IS_DIRTY			= cpu_to_le16(0x0001),$/;"	e	enum:__anon91
VOLUME_MODIFIED_BY_CHKDSK	layout.h	/^	VOLUME_MODIFIED_BY_CHKDSK	= cpu_to_le16(0x8000),$/;"	e	enum:__anon91
VOLUME_MOUNTED_ON_NT4	layout.h	/^	VOLUME_MOUNTED_ON_NT4		= cpu_to_le16(0x0008),$/;"	e	enum:__anon91
VOLUME_MUST_MOUNT_RO_MASK	layout.h	/^	VOLUME_MUST_MOUNT_RO_MASK	= cpu_to_le16(0xc027),$/;"	e	enum:__anon91
VOLUME_NAME	layout.h	/^} __attribute__ ((__packed__)) VOLUME_NAME;$/;"	t	typeref:struct:__anon90
VOLUME_REPAIR_OBJECT_ID	layout.h	/^	VOLUME_REPAIR_OBJECT_ID		= cpu_to_le16(0x0020),$/;"	e	enum:__anon91
VOLUME_RESIZE_LOG_FILE	layout.h	/^	VOLUME_RESIZE_LOG_FILE		= cpu_to_le16(0x0002),$/;"	e	enum:__anon91
VOLUME_UPGRADE_ON_MOUNT	layout.h	/^	VOLUME_UPGRADE_ON_MOUNT		= cpu_to_le16(0x0004),$/;"	e	enum:__anon91
WRITE_DAC	layout.h	/^	WRITE_DAC			= cpu_to_le32(0x00040000),$/;"	e	enum:__anon75
WRITE_OWNER	layout.h	/^	WRITE_OWNER			= cpu_to_le32(0x00080000),$/;"	e	enum:__anon75
XXX_LOCK_USAGE_STATES	lockdep.h	26;"	d
_LINUX_NTFS_AOPS_H	aops.h	25;"	d
_LINUX_NTFS_ATTRIB_H	attrib.h	25;"	d
_LINUX_NTFS_BITMAP_H	bitmap.h	24;"	d
_LINUX_NTFS_COLLATE_H	collate.h	24;"	d
_LINUX_NTFS_DEBUG_H	debug.h	23;"	d
_LINUX_NTFS_DIR_H	dir.h	24;"	d
_LINUX_NTFS_ENDIAN_H	endian.h	24;"	d
_LINUX_NTFS_H	ntfs.h	25;"	d
_LINUX_NTFS_INDEX_H	index.h	24;"	d
_LINUX_NTFS_INODE_H	inode.h	25;"	d
_LINUX_NTFS_LAYOUT_H	layout.h	25;"	d
_LINUX_NTFS_LCNALLOC_H	lcnalloc.h	24;"	d
_LINUX_NTFS_LOGFILE_H	logfile.h	24;"	d
_LINUX_NTFS_MALLOC_H	malloc.h	23;"	d
_LINUX_NTFS_MFT_H	mft.h	24;"	d
_LINUX_NTFS_QUOTA_H	quota.h	24;"	d
_LINUX_NTFS_RUNLIST_H	runlist.h	25;"	d
_LINUX_NTFS_SYSCTL_H	sysctl.h	25;"	d
_LINUX_NTFS_TIME_H	time.h	23;"	d
_LINUX_NTFS_TYPES_H	types.h	24;"	d
_LINUX_NTFS_USNJRNL_H	usnjrnl.h	24;"	d
_LINUX_NTFS_VOLUME_H	volume.h	25;"	d
__DEBUG_MUTEX_INITIALIZER	mutex.h	83;"	d
__DEP_MAP_MUTEX_INITIALIZER	mutex.h	94;"	d
__DEP_MAP_MUTEX_INITIALIZER	mutex.h	97;"	d
__IS_FLG	ntfs_g.h	288;"	d
__LINUX_LOCKDEP_H	lockdep.h	10;"	d
__LINUX_MUTEX_H	mutex.h	11;"	d
__MUTEX_INITIALIZER	mutex.h	100;"	d
__NTFS_G_H__	ntfs_g.h	2;"	d
__d_instantiate	ntfs_g.c	/^static void __d_instantiate(struct dentry *dentry, struct inode *inode)$/;"	f	file:
__get_nr_free_mft_records	super.c	/^static unsigned long __get_nr_free_mft_records(ntfs_volume *vol,$/;"	f	file:
__mark_mft_record_dirty	mft.c	/^void __mark_mft_record_dirty(ntfs_inode *ni)$/;"	f
__mutex_fastpath_trylock	ntfs_g.h	/^static inline int __mutex_fastpath_trylock(atomic_t *count,$/;"	f
__ntfs_bitmap_set_bits_in_run	bitmap.c	/^int __ntfs_bitmap_set_bits_in_run(struct inode *vi, const s64 start_bit,$/;"	f
__ntfs_clear_inode	inode.c	/^static void __ntfs_clear_inode(ntfs_inode *ni)$/;"	f	file:
__ntfs_cluster_free	lcnalloc.c	/^s64 __ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn, s64 count,$/;"	f
__ntfs_copy_from_user_iovec_inatomic	file.c	/^static size_t __ntfs_copy_from_user_iovec_inatomic(char *vaddr,$/;"	f	file:
__ntfs_create	namei.c	/^static ntfs_inode *__ntfs_create(ntfs_inode *dir_ni,$/;"	f	file:
__ntfs_debug	debug.c	/^void __ntfs_debug (const char *file, int line, const char *function,$/;"	f
__ntfs_error	debug.c	/^void __ntfs_error(const char *function, const struct super_block *sb,$/;"	f
__ntfs_error_attr	debug.c	/^void __ntfs_error_attr(const char *function, const struct super_block *sb, ATTR_REC *attr)$/;"	f
__ntfs_grab_cache_pages	file.c	/^static \/*inline*\/ int __ntfs_grab_cache_pages(struct address_space *mapping,$/;"	f	file:
__ntfs_init_inode	inode.c	/^void __ntfs_init_inode(struct super_block *sb, ntfs_inode *ni)$/;"	f
__ntfs_is_magic	layout.h	/^static inline bool __ntfs_is_magic(le32 x, NTFS_RECORD_TYPE r)$/;"	f
__ntfs_is_magicp	layout.h	/^static inline bool __ntfs_is_magicp(le32 *p, NTFS_RECORD_TYPE r)$/;"	f
__ntfs_malloc	malloc.h	/^static inline void *__ntfs_malloc(unsigned long size, gfp_t gfp_mask)$/;"	f
__ntfs_rl_merge	runlist.c	/^static inline void __ntfs_rl_merge(runlist_element *dst, runlist_element *src)$/;"	f	file:
__ntfs_warning	debug.c	/^void __ntfs_warning(const char *function, const struct super_block *sb,$/;"	f
__one_byte	lockdep.h	/^	char __one_byte;$/;"	m	struct:lockdep_subclass_key
__remove_suid	ntfs_g.c	/^static int __remove_suid(struct dentry *dentry, int kill)$/;"	f	file:
_ntfs_inode	inode.h	/^struct _ntfs_inode {$/;"	s
ace_count	layout.h	/^	le16 ace_count;	\/* Number of ACEs in the ACL. *\/$/;"	m	struct:__anon80
acquire_ip	lockdep.h	/^	unsigned long			acquire_ip;$/;"	m	struct:held_lock
actx	index.h	/^	ntfs_attr_search_ctx *actx;$/;"	m	struct:__anon15
al_entry	attrib.h	/^	ATTR_LIST_ENTRY *al_entry;$/;"	m	struct:__anon14
alignment	layout.h	/^	u8 alignment;$/;"	m	struct:__anon83
alignment	layout.h	/^	u8 alignment;$/;"	m	struct:__anon84
alignment1	layout.h	/^	u8 alignment1;$/;"	m	struct:__anon80
alignment2	layout.h	/^	le16 alignment2;$/;"	m	struct:__anon80
allocate_compression_buffers	compress.c	/^int allocate_compression_buffers(void)$/;"	f
allocated_size	inode.h	/^	s64 allocated_size;	\/* Copy from the attribute record. *\/$/;"	m	struct:_ntfs_inode
allocated_size	layout.h	/^	le32 allocated_size;		\/* Byte size of this index (block),$/;"	m	struct:__anon95
allocated_size	layout.h	/^\/* 28*\/	sle64 allocated_size;		\/* Byte size of on-disk allocated space$/;"	m	struct:__anon56
allocated_size	layout.h	/^\/* 40*\/			sle64 allocated_size;	\/* Byte size of disk space$/;"	m	struct:__anon45::__anon46::__anon48
allocation_delta	usnjrnl.h	/^\/*   8*\/sle64 allocation_delta;	\/* Number of bytes by which to increase the$/;"	m	struct:__anon6
attr	attrib.h	/^	ATTR_RECORD *attr;$/;"	m	struct:__anon14
attr_list	inode.h	/^	u8 *attr_list;		\/* Attribute list value itself. *\/$/;"	m	struct:_ntfs_inode
attr_list_rl	inode.h	/^	runlist attr_list_rl;	\/* Run list for the attribute list value. *\/$/;"	m	struct:_ntfs_inode
attr_list_rl_lock_class	inode.c	/^static struct lock_class_key attr_list_rl_lock_class;$/;"	v	typeref:struct:lock_class_key	file:
attr_list_size	inode.h	/^	u32 attr_list_size;	\/* Length of attribute list value in bytes. *\/$/;"	m	struct:_ntfs_inode
attrdef	volume.h	/^	ATTR_DEF *attrdef;		\/* Table of attribute definitions.  Obtained from FILE_AttrDef. *\/$/;"	m	struct:__anon4
attrdef_size	volume.h	/^	s32 attrdef_size;		\/* Size of the attribute definition table in bytes. *\/$/;"	m	struct:__anon4
attrs_offset	layout.h	/^\/* 20*\/	le16 attrs_offset;	\/* Byte offset to the first attribute in this$/;"	m	struct:__anon37
attrs_offset	layout.h	/^\/* 20*\/	le16 attrs_offset;	\/* Byte offset to the first attribute in this$/;"	m	struct:__anon38
base	lockdep.h	/^	u16				base;$/;"	m	struct:lock_chain
base_attr	attrib.h	/^	ATTR_RECORD *base_attr;$/;"	m	struct:__anon14
base_mft_record	layout.h	/^\/* 32*\/	leMFT_REF base_mft_record;\/* This is zero for base mft records.$/;"	m	struct:__anon37
base_mft_record	layout.h	/^\/* 32*\/	leMFT_REF base_mft_record;\/* This is zero for base mft records.$/;"	m	struct:__anon38
base_mrec	attrib.h	/^	MFT_RECORD *base_mrec;$/;"	m	struct:__anon14
base_ni	index.h	/^	ntfs_inode *base_ni;$/;"	m	struct:__anon15
base_ntfs_ino	attrib.h	/^	ntfs_inode *base_ntfs_ino;$/;"	m	struct:__anon14
base_ntfs_ino	inode.h	/^		ntfs_inode *base_ntfs_ino;	\/* For nr_extents == -1, the$/;"	m	union:_ntfs_inode::__anon27
big_ntfs_inode	inode.h	/^} big_ntfs_inode;$/;"	t	typeref:struct:__anon29
birth_object_id	layout.h	/^			GUID birth_object_id;	\/* Unique id of file when it was$/;"	m	struct:__anon64::__anon65::__anon66
birth_object_id	layout.h	/^			GUID birth_object_id;$/;"	m	struct:__anon61::__anon62::__anon63
birth_volume_id	layout.h	/^			GUID birth_volume_id;	\/* Unique id of volume on which$/;"	m	struct:__anon64::__anon65::__anon66
birth_volume_id	layout.h	/^			GUID birth_volume_id;$/;"	m	struct:__anon61::__anon62::__anon63
bitmap	layout.h	/^	u8 bitmap[0];			\/* Array of bits. *\/$/;"	m	struct:__anon113
block_clusters	inode.h	/^			u8 block_clusters;	\/* Number of clusters per cb. *\/$/;"	m	struct:_ntfs_inode::__anon24::__anon26
block_size	inode.h	/^			u32 block_size;		\/* Size of a compression block$/;"	m	struct:_ntfs_inode::__anon24::__anon26
block_size	inode.h	/^			u32 block_size;		\/* Size of an index block. *\/$/;"	m	struct:_ntfs_inode::__anon24::__anon25
block_size_bits	inode.h	/^			u8 block_size_bits;	\/* Log2 of the size of a cb. *\/$/;"	m	struct:_ntfs_inode::__anon24::__anon26
block_size_bits	inode.h	/^			u8 block_size_bits; 	\/* Log2 of the above. *\/$/;"	m	struct:_ntfs_inode::__anon24::__anon25
bool	ntfs_g.h	/^typedef enum{false = 0, true} bool;$/;"	t	typeref:enum:__anon21
bootstrap	layout.h	/^\/*0x54*\/u8  bootstrap[426];		\/* Irrelevant (boot up code). *\/$/;"	m	struct:__anon32
bounce_acquired	lockdep.h	/^	bounce_acquired = bounce_acquired_write,$/;"	e	enum:bounce_type
bounce_acquired_read	lockdep.h	/^	bounce_acquired_read,$/;"	e	enum:bounce_type
bounce_acquired_write	lockdep.h	/^	bounce_acquired_write,$/;"	e	enum:bounce_type
bounce_contended	lockdep.h	/^	bounce_contended = bounce_contended_write,$/;"	e	enum:bounce_type
bounce_contended_read	lockdep.h	/^	bounce_contended_read,$/;"	e	enum:bounce_type
bounce_contended_write	lockdep.h	/^	bounce_contended_write,$/;"	e	enum:bounce_type
bounce_type	lockdep.h	/^enum bounce_type {$/;"	g
bounces	lockdep.h	/^	unsigned long			bounces[nr_bounce_types];$/;"	m	struct:lock_class_stats
bpb	layout.h	/^	BIOS_PARAMETER_BLOCK bpb;	\/* See BIOS_PARAMETER_BLOCK. *\/$/;"	m	struct:__anon32
bytes_allocated	layout.h	/^\/* 28*\/	le32 bytes_allocated;	\/* Number of bytes allocated for this mft$/;"	m	struct:__anon37
bytes_allocated	layout.h	/^\/* 28*\/	le32 bytes_allocated;	\/* Number of bytes allocated for this mft$/;"	m	struct:__anon38
bytes_in_use	layout.h	/^\/* 24*\/	le32 bytes_in_use;	\/* Number of bytes used in this mft record.$/;"	m	struct:__anon37
bytes_in_use	layout.h	/^\/* 24*\/	le32 bytes_in_use;	\/* Number of bytes used in this mft record.$/;"	m	struct:__anon38
bytes_per_sector	layout.h	/^	le16 bytes_per_sector;		\/* Size of a sector in bytes. *\/$/;"	m	struct:__anon31
bytes_used	layout.h	/^	le64 bytes_used;	\/* How many bytes of the quota are in use. *\/$/;"	m	struct:__anon100
cap_inode_killpriv	ntfs_g.c	/^EXPORT_SYMBOL(cap_inode_killpriv);$/;"	v
cap_inode_killpriv	ntfs_g.c	/^int cap_inode_killpriv(struct dentry *dentry)$/;"	f
cap_inode_need_killpriv	ntfs_g.c	/^EXPORT_SYMBOL(cap_inode_need_killpriv);$/;"	v
cap_inode_need_killpriv	ntfs_g.c	/^int cap_inode_need_killpriv(struct dentry *dentry)$/;"	f
chain_key	lockdep.h	/^	u64				chain_key;$/;"	m	struct:lock_chain
change_time	layout.h	/^	sle64 change_time;	\/* Last time this quota entry was changed. *\/$/;"	m	struct:__anon100
check	lockdep.h	/^	unsigned int check:2;       \/* see lock_acquire() comment *\/$/;"	m	struct:held_lock
check_mft_mirror	super.c	/^static bool check_mft_mirror(ntfs_volume *vol)$/;"	f	file:
check_windows_hibernation_status	super.c	/^static int check_windows_hibernation_status(ntfs_volume *vol)$/;"	f	file:
checksum	layout.h	/^	le32 checksum;			\/* Boot sector checksum. *\/$/;"	m	struct:__anon32
chkdsk_lsn	logfile.h	/^\/*  8*\/	leLSN chkdsk_lsn;	\/* The last log file sequence number found by$/;"	m	struct:__anon10
class_cache	lockdep.h	/^	struct lock_class		*class_cache;$/;"	m	struct:lockdep_map	typeref:struct:lockdep_map::lock_class
class_id	layout.h	/^		\/* 44*\/	le32 class_id;		\/* Class id from bidirectional$/;"	m	struct:__anon50::__anon51::__anon53
class_idx	lockdep.h	/^	unsigned int			class_idx:MAX_LOCKDEP_KEYS_BITS;$/;"	m	struct:held_lock
clear_nlink	ntfs_g.h	81;"	d
client_array_offset	logfile.h	/^\/* 22*\/	le16 client_array_offset;\/* Offset from the start of this record to$/;"	m	struct:__anon12
client_free_list	logfile.h	/^\/* 10*\/	le16 client_free_list;	\/* The index of the first free log client record$/;"	m	struct:__anon12
client_in_use_list	logfile.h	/^\/* 12*\/	le16 client_in_use_list;\/* The index of the first in-use log client$/;"	m	struct:__anon12
client_name	logfile.h	/^\/* 32*\/	ntfschar client_name[64];\/* Name of the client in Unicode.  Should$/;"	m	struct:__anon13
client_name_length	logfile.h	/^\/* 28*\/	le32 client_name_length;\/* Length of client name in bytes.  Should$/;"	m	struct:__anon13
client_restart_lsn	logfile.h	/^\/*  8*\/	leLSN client_restart_lsn;\/* LSN at which this client needs to restart$/;"	m	struct:__anon13
cluster_size	volume.h	/^	u32 cluster_size;		\/* in bytes *\/$/;"	m	struct:__anon4
cluster_size_bits	volume.h	/^	u8 cluster_size_bits;		\/* log2(cluster_size) *\/$/;"	m	struct:__anon4
cluster_size_mask	volume.h	/^	u32 cluster_size_mask;		\/* cluster_size - 1 *\/$/;"	m	struct:__anon4
clusters_per_index_block	layout.h	/^	u8 clusters_per_index_block;	\/* Cluster size of each index block (in$/;"	m	struct:__anon96
clusters_per_index_record	layout.h	/^	s8  clusters_per_index_record;	\/* Index block size in clusters. *\/$/;"	m	struct:__anon32
clusters_per_mft_record	layout.h	/^	s8  clusters_per_mft_record;	\/* Mft record size in clusters. *\/$/;"	m	struct:__anon32
collation_rule	inode.h	/^			COLLATION_RULE collation_rule; \/* The collation rule$/;"	m	struct:_ntfs_inode::__anon24::__anon25
collation_rule	layout.h	/^	COLLATION_RULE collation_rule;	\/* Collation rule used to sort the$/;"	m	struct:__anon96
collation_rule	layout.h	/^\/* 88*\/ COLLATION_RULE collation_rule;	\/* Default collation rule. *\/$/;"	m	struct:__anon42
compressed	inode.h	/^		} compressed;$/;"	m	union:_ntfs_inode::__anon24	typeref:struct:_ntfs_inode::__anon24::__anon26
compressed_size	layout.h	/^\/* 64*\/			sle64 compressed_size;	\/* Byte size of the attribute$/;"	m	struct:__anon45::__anon46::__anon48
compression_unit	layout.h	/^\/* 34*\/			u8 compression_unit; \/* The compression unit expressed$/;"	m	struct:__anon45::__anon46::__anon48
contending_point	lockdep.h	/^	unsigned long			contending_point[4];$/;"	m	struct:lock_class_stats
contending_point	lockdep.h	/^	unsigned long			contending_point[LOCKSTAT_POINTS];$/;"	m	struct:lock_class
contention_point	lockdep.h	/^	unsigned long			contention_point[4];$/;"	m	struct:lock_class_stats
contention_point	lockdep.h	/^	unsigned long			contention_point[LOCKSTAT_POINTS];$/;"	m	struct:lock_class
control	layout.h	/^	SECURITY_DESCRIPTOR_CONTROL control;	\/* Flags qualifying the type of$/;"	m	struct:__anon84
control	layout.h	/^	SECURITY_DESCRIPTOR_CONTROL control; \/* Flags qualifying the type of$/;"	m	struct:__anon83
count	inode.h	/^	atomic_t count;		\/* Inode reference count for book keeping. *\/$/;"	m	struct:_ntfs_inode
count	mutex.h	/^	atomic_t		count;$/;"	m	struct:mutex
cpu	lockdep.h	/^	int				cpu;$/;"	m	struct:lockdep_map
cpu_to_sle16	endian.h	/^static inline sle16 cpu_to_sle16(s16 x)$/;"	f
cpu_to_sle16p	endian.h	/^static inline sle16 cpu_to_sle16p(s16 *x)$/;"	f
cpu_to_sle32	endian.h	/^static inline sle32 cpu_to_sle32(s32 x)$/;"	f
cpu_to_sle32p	endian.h	/^static inline sle32 cpu_to_sle32p(s32 *x)$/;"	f
cpu_to_sle64	endian.h	/^static inline sle64 cpu_to_sle64(s64 x)$/;"	f
cpu_to_sle64p	endian.h	/^static inline sle64 cpu_to_sle64p(s64 *x)$/;"	f
creation_time	layout.h	/^\/*  0*\/	sle64 creation_time;		\/* Time file was created. Updated when$/;"	m	struct:__anon50
creation_time	layout.h	/^\/*  8*\/	sle64 creation_time;		\/* Time file was created. *\/$/;"	m	struct:__anon56
current_fsuid	ntfs_g.h	96;"	d
current_gid	ntfs_g.h	95;"	d
current_lsn	logfile.h	/^\/*  0*\/	leLSN current_lsn;	\/* The current, i.e. last LSN inside the log$/;"	m	struct:__anon12
current_uid	ntfs_g.h	94;"	d
d_add_ci	ntfs_g.c	/^EXPORT_SYMBOL(d_add_ci);$/;"	v
d_add_ci	ntfs_g.c	/^struct dentry *d_add_ci(struct dentry *dentry, struct inode *inode,$/;"	f
d_hash_and_lookup	ntfs_g.c	/^struct dentry *d_hash_and_lookup(struct dentry *dir, struct qstr *name)$/;"	f
dacl	layout.h	/^	ACL *dacl;	\/* Points to a discretionary ACL. Only valid, if$/;"	m	struct:__anon84
dacl	layout.h	/^	le32 dacl;	\/* Byte offset to a discretionary ACL. Only valid, if$/;"	m	struct:__anon83
data	index.h	/^	void *data;$/;"	m	struct:__anon15
data	layout.h	/^	u8 data[0];		\/* The file's data contents. *\/$/;"	m	struct:__anon93
data	layout.h	/^	} __attribute__ ((__packed__)) data;$/;"	m	struct:__anon104	typeref:union:__anon104::__anon105
data	layout.h	/^	} __attribute__ ((__packed__)) data;$/;"	m	struct:__anon108	typeref:union:__anon108::__anon109
data	layout.h	/^	} __attribute__ ((__packed__)) data;$/;"	m	struct:__anon45	typeref:union:__anon45::__anon46
data1	layout.h	/^	le32 data1;	\/* The first eight hexadecimal digits of the GUID. *\/$/;"	m	struct:__anon60
data1_zone_pos	volume.h	/^	LCN data1_zone_pos;		\/* Current position in the first data$/;"	m	struct:__anon4
data2	layout.h	/^	le16 data2;	\/* The first group of four hexadecimal digits. *\/$/;"	m	struct:__anon60
data2_zone_pos	volume.h	/^	LCN data2_zone_pos;		\/* Current position in the second data$/;"	m	struct:__anon4
data3	layout.h	/^	le16 data3;	\/* The second group of four hexadecimal digits. *\/$/;"	m	struct:__anon60
data4	layout.h	/^	u8 data4[8];	\/* The first two bytes are the third group of four$/;"	m	struct:__anon60
data_len	index.h	/^	u16 data_len;$/;"	m	struct:__anon15
data_length	layout.h	/^			le16 data_length;	\/* Data length in bytes. *\/$/;"	m	struct:__anon104::__anon105::__anon107
data_length	layout.h	/^			le16 data_length;	\/* Data length in bytes. *\/$/;"	m	struct:__anon108::__anon109::__anon111
data_offset	layout.h	/^			le16 data_offset;	\/* Data byte offset from this$/;"	m	struct:__anon104::__anon105::__anon107
data_offset	layout.h	/^			le16 data_offset;	\/* Data byte offset from this$/;"	m	struct:__anon108::__anon109::__anon111
data_size	layout.h	/^\/* 30*\/	sle64 data_size;		\/* Byte size of actual data in unnamed$/;"	m	struct:__anon56
data_size	layout.h	/^\/* 48*\/			sle64 data_size;	\/* Byte size of the attribute$/;"	m	struct:__anon45::__anon46::__anon48
debug_msgs	debug.c	/^int debug_msgs = 1;$/;"	v
default_upcase	super.c	/^static ntfschar *default_upcase = NULL;$/;"	v	file:
default_upcase_len	ntfs.h	93;"	d
dep_gen_id	lockdep.h	/^	unsigned int			dep_gen_id;$/;"	m	struct:lock_class
dep_map	mutex.h	/^	struct lockdep_map	dep_map;$/;"	m	struct:mutex	typeref:struct:mutex::lockdep_map
depth	lockdep.h	/^	u8				depth;$/;"	m	struct:lock_chain
dir	layout.h	/^		} __attribute__ ((__packed__)) dir;$/;"	m	union:__anon104::__anon105	typeref:struct:__anon104::__anon105::__anon106
dir	layout.h	/^		} __attribute__ ((__packed__)) dir;$/;"	m	union:__anon108::__anon109	typeref:struct:__anon108::__anon109::__anon110
display_rule	layout.h	/^\/* 84*\/	le32 display_rule;		\/* Default display rule.$/;"	m	struct:__anon42
distance	lockdep.h	/^	int				distance;$/;"	m	struct:lock_list
dmask	volume.h	/^	mode_t dmask;			\/* The mask for directory$/;"	m	struct:__anon4
domain_id	layout.h	/^			GUID domain_id;		\/* Reserved, zero. *\/$/;"	m	struct:__anon64::__anon65::__anon66
domain_id	layout.h	/^			GUID domain_id;$/;"	m	struct:__anon61::__anon62::__anon63
ea	layout.h	/^		} __attribute__ ((__packed__)) ea;$/;"	m	union:__anon56::__anon57	typeref:struct:__anon56::__anon57::__anon58
ea_length	layout.h	/^	le16 ea_length;		\/* Byte size of the packed extended$/;"	m	struct:__anon116
ea_name	layout.h	/^	u8 ea_name[0];		\/* Name of the EA.  Note this is ASCII, not$/;"	m	struct:__anon118
ea_name_length	layout.h	/^	u8 ea_name_length;	\/* Length of the name of the EA in bytes$/;"	m	struct:__anon118
ea_query_length	layout.h	/^	le32 ea_query_length;	\/* Byte size of the buffer required to query$/;"	m	struct:__anon116
ea_value	layout.h	/^	u8 ea_value[0];		\/* The value of the EA.  Immediately follows$/;"	m	struct:__anon118
ea_value_length	layout.h	/^	le16 ea_value_length;	\/* Byte size of the EA's value. *\/$/;"	m	struct:__anon118
early_boot_irqs_off	lockdep.h	/^static inline void early_boot_irqs_off(void)$/;"	f
early_boot_irqs_on	lockdep.h	/^static inline void early_boot_irqs_on(void)$/;"	f
early_init_irq_lock_class	lockdep.h	/^static inline void early_init_irq_lock_class(void)$/;"	f
end_of_sector_marker	layout.h	/^	le16 end_of_sector_marker;	\/* End of bootsector magic. Always is$/;"	m	struct:__anon32
entries_offset	layout.h	/^	le32 entries_offset;		\/* Byte offset to first INDEX_ENTRY$/;"	m	struct:__anon95
entry	index.h	/^	INDEX_ENTRY *entry;$/;"	m	struct:__anon15
entry	lockdep.h	/^	struct list_head		entry;$/;"	m	struct:lock_chain	typeref:struct:lock_chain::list_head
entry	lockdep.h	/^	struct list_head		entry;$/;"	m	struct:lock_list	typeref:struct:lock_list::list_head
err_buf	debug.c	/^static char err_buf[1024];$/;"	v	file:
es	inode.c	/^static const char *es = "  Leaving inconsistent metadata.  Unmount and run "$/;"	v	file:
es	mft.c	/^static const char *es = "  Leaving inconsistent metadata.  Unmount and run "$/;"	v	file:
exceeded_time	layout.h	/^	sle64 exceeded_time;	\/* How long the soft quota has been exceeded. *\/$/;"	m	struct:__anon100
exit_ntfs_fs	super.c	/^static void __exit exit_ntfs_fs(void)$/;"	f	file:
ext	inode.h	/^	} ext;$/;"	m	struct:_ntfs_inode	typeref:union:_ntfs_inode::__anon27
extend_ino	volume.h	/^	struct inode *extend_ino;	\/* The VFS inode of $Extend (NTFS3.0+$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
extended_info	layout.h	/^		u8 extended_info[48];$/;"	m	union:__anon61::__anon62
extended_info	layout.h	/^		u8 extended_info[48];$/;"	m	union:__anon64::__anon65
extent_inode_mrec_lock_key	inode.c	/^static struct lock_class_key extent_inode_mrec_lock_key;$/;"	v	typeref:struct:lock_class_key	file:
extent_lock	inode.h	/^	struct mutex extent_lock;	\/* Lock for accessing\/modifying the$/;"	m	struct:_ntfs_inode	typeref:struct:_ntfs_inode::mutex
extent_ntfs_inos	inode.h	/^		ntfs_inode **extent_ntfs_inos;	\/* For nr_extents > 0, array of$/;"	m	union:_ntfs_inode::__anon27
false	ntfs_g.h	/^typedef enum{false = 0, true} bool;$/;"	e	enum:__anon21
fats	layout.h	/^	u8  fats;			\/* zero *\/$/;"	m	struct:__anon31
file_attributes	layout.h	/^\/* 32*\/	FILE_ATTR_FLAGS file_attributes; \/* Flags describing the file. *\/$/;"	m	struct:__anon50
file_attributes	layout.h	/^\/* 38*\/	FILE_ATTR_FLAGS file_attributes;	\/* Flags describing the file. *\/$/;"	m	struct:__anon56
file_attributes	usnjrnl.h	/^\/*0x34*\/FILE_ATTR_FLAGS file_attributes;	\/* File attributes copied from$/;"	m	struct:__anon9
file_id	layout.h	/^	leMFT_REF file_id;	\/* Mft record of the file containing the$/;"	m	struct:__anon98
file_name	layout.h	/^		FILE_NAME_ATTR file_name;\/* $I30 index in directories. *\/$/;"	m	union:__anon108::__anon112
file_name	layout.h	/^\/* 42*\/	ntfschar file_name[0];			\/* File name in Unicode. *\/$/;"	m	struct:__anon56
file_name	usnjrnl.h	/^\/*0x3c*\/ntfschar file_name[0];	\/* Use when creating only.  When reading use$/;"	m	struct:__anon9
file_name_length	layout.h	/^\/* 40*\/	u8 file_name_length;			\/* Length of file name in$/;"	m	struct:__anon56
file_name_offset	usnjrnl.h	/^\/*0x3a*\/le16 file_name_offset;	\/* Offset to the file name in bytes from the$/;"	m	struct:__anon9
file_name_size	usnjrnl.h	/^\/*0x38*\/le16 file_name_size;	\/* Size of the file name in bytes. *\/$/;"	m	struct:__anon9
file_name_type	layout.h	/^\/* 41*\/	FILE_NAME_TYPE_FLAGS file_name_type;	\/* Namespace of the file name.*\/$/;"	m	struct:__anon56
file_remove_suid	ntfs_g.c	/^EXPORT_SYMBOL(file_remove_suid);$/;"	v
file_remove_suid	ntfs_g.c	/^int file_remove_suid(struct file *file)$/;"	f
file_size	logfile.h	/^\/* 24*\/	sle64 file_size;	\/* Usable byte size of the log file.  If the$/;"	m	struct:__anon12
file_update_time	ntfs_g.c	/^EXPORT_SYMBOL(file_update_time);$/;"	v
file_update_time	ntfs_g.c	/^void file_update_time(struct file *file)$/;"	f
flags	layout.h	/^	ACE_FLAGS flags;	\/* Flags describing the ACE. *\/$/;"	m	struct:__anon77
flags	layout.h	/^	ACE_FLAGS flags;	\/* Flags describing the ACE. *\/$/;"	m	struct:__anon79
flags	layout.h	/^	EA_FLAGS flags;		\/* Flags describing the EA. *\/$/;"	m	struct:__anon118
flags	layout.h	/^	INDEX_ENTRY_FLAGS flags; \/* Bit field of INDEX_ENTRY_* flags. *\/$/;"	m	struct:__anon108
flags	layout.h	/^	INDEX_HEADER_FLAGS flags;	\/* Bit field of INDEX_HEADER_FLAGS. *\/$/;"	m	struct:__anon95
flags	layout.h	/^	QUOTA_FLAGS flags;	\/* Flags describing this quota entry. *\/$/;"	m	struct:__anon100
flags	layout.h	/^	VOLUME_FLAGS flags;	\/* Bit array of VOLUME_* flags. *\/$/;"	m	struct:__anon92
flags	layout.h	/^\/*  1*\/	ACE_FLAGS flags;	\/* Flags describing the ACE. *\/$/;"	m	struct:__anon74
flags	layout.h	/^\/* 12*\/	ATTR_FLAGS flags;	\/* Flags describing the attribute. *\/$/;"	m	struct:__anon45
flags	layout.h	/^\/* 12*\/	INDEX_ENTRY_FLAGS flags; \/* Bit field of INDEX_ENTRY_* flags. *\/$/;"	m	struct:__anon104
flags	layout.h	/^\/* 22 *\/		RESIDENT_ATTR_FLAGS flags; \/* See above. *\/$/;"	m	struct:__anon45::__anon46::__anon47
flags	layout.h	/^\/* 22*\/	MFT_RECORD_FLAGS flags;	\/* Bit array of MFT_RECORD_FLAGS. When a file$/;"	m	struct:__anon37
flags	layout.h	/^\/* 22*\/	MFT_RECORD_FLAGS flags;	\/* Bit array of MFT_RECORD_FLAGS. When a file$/;"	m	struct:__anon38
flags	layout.h	/^\/* 8c*\/	ATTR_DEF_FLAGS flags;		\/* Flags describing the attribute. *\/$/;"	m	struct:__anon42
flags	logfile.h	/^\/* 14*\/	RESTART_AREA_FLAGS flags;\/* Flags modifying LFS behaviour.  On Win2k$/;"	m	struct:__anon12
flags	volume.h	/^	unsigned long flags;		\/* Miscellaneous flags, see below. *\/$/;"	m	struct:__anon4
flush_dcache_mft_record_page	mft.h	/^static inline void flush_dcache_mft_record_page(ntfs_inode *ni)$/;"	f
fmask	volume.h	/^	mode_t fmask;			\/* The mask for file permissions. *\/$/;"	m	struct:__anon4
free_compression_buffers	compress.c	/^void free_compression_buffers(void)$/;"	f
fsnotify_d_instantiate	ntfs_g.h	/^static inline void fsnotify_d_instantiate(struct dentry *entry,$/;"	f
generate_default_upcase	upcase.c	/^ntfschar *generate_default_upcase(void)$/;"	f
generic_all	layout.h	/^	ACCESS_MASK generic_all;$/;"	m	struct:__anon76
generic_execute	layout.h	/^	ACCESS_MASK generic_execute;$/;"	m	struct:__anon76
generic_read	layout.h	/^	ACCESS_MASK generic_read;$/;"	m	struct:__anon76
generic_segment_checks	ntfs_g.c	/^EXPORT_SYMBOL(generic_segment_checks);$/;"	v
generic_segment_checks	ntfs_g.c	/^int generic_segment_checks(const struct iovec *iov,$/;"	f
generic_write	layout.h	/^	ACCESS_MASK generic_write;$/;"	m	struct:__anon76
get_current_ntfs_time	time.h	/^static inline sle64 get_current_ntfs_time(void)$/;"	f
get_nr_free_clusters	super.c	/^static s64 get_nr_free_clusters(ntfs_volume *vol)$/;"	f	file:
gid	volume.h	/^	gid_t gid;			\/* gid that files will be mounted as. *\/$/;"	m	struct:__anon4
group	layout.h	/^	SID *group;	\/* Points to a SID representing an object's primary$/;"	m	struct:__anon84
group	layout.h	/^	le32 group;	\/* Byte offset to a SID representing an object's$/;"	m	struct:__anon83
gzged_ntfs_create	namei.c	/^static int gzged_ntfs_create(struct inode *dir,$/;"	f	file:
gzged_ntfs_unlink	namei.c	/^static int gzged_ntfs_unlink(struct inode *pi,struct dentry *pd)$/;"	f	file:
handle_bounds_compressed_page	compress.c	/^static inline void handle_bounds_compressed_page(struct page *page,$/;"	f	file:
hardirqs_off	lockdep.h	/^	unsigned int hardirqs_off:1;$/;"	m	struct:held_lock
hash	layout.h	/^	le32 hash;	  \/* Hash of the security descriptor. *\/$/;"	m	struct:__anon86
hash	layout.h	/^	le32 hash;	  \/* Hash of the security descriptor. *\/$/;"	m	struct:__anon87
hash	layout.h	/^	le32 hash;	  \/* Hash of the security descriptor. *\/$/;"	m	struct:__anon89
hash_entry	lockdep.h	/^	struct list_head		hash_entry;$/;"	m	struct:lock_class	typeref:struct:lock_class::list_head
heads	layout.h	/^	le16 heads;			\/* irrelevant *\/$/;"	m	struct:__anon31
held_lock	lockdep.h	/^struct held_lock {$/;"	s
hidden_sectors	layout.h	/^	le32 hidden_sectors;		\/* zero *\/$/;"	m	struct:__anon31
high_part	layout.h	/^		u16 high_part;	\/* High 16-bits. *\/$/;"	m	struct:__anon68::__anon69
highest_vcn	layout.h	/^\/* 24*\/			leVCN highest_vcn;\/* Highest valid vcn of this extent of$/;"	m	struct:__anon45::__anon46::__anon48
holdtime_stamp	lockdep.h	/^	u64				holdtime_stamp;$/;"	m	struct:held_lock
i_mutex	ntfs_g.h	40;"	d
ia	index.h	/^	INDEX_ALLOCATION *ia;$/;"	m	struct:__anon15
identifier_authority	layout.h	/^	SID_IDENTIFIER_AUTHORITY identifier_authority;$/;"	m	struct:__anon70
idx_ni	index.h	/^	ntfs_inode *idx_ni;$/;"	m	struct:__anon15
inc_nlink	ntfs_g.h	82;"	d
index	inode.h	/^		} index;$/;"	m	union:_ntfs_inode::__anon24	typeref:struct:_ntfs_inode::__anon24::__anon25
index	layout.h	/^	INDEX_HEADER index;		\/* Index header describing the$/;"	m	struct:__anon96
index	layout.h	/^\/* 24*\/	INDEX_HEADER index;	\/* Describes the following index entries. *\/$/;"	m	struct:__anon97
index_block_size	layout.h	/^	le32 index_block_size;		\/* Size of each index block in bytes (in$/;"	m	struct:__anon96
index_block_vcn	layout.h	/^\/* 16*\/	leVCN index_block_vcn;	\/* Virtual cluster number of the index block.$/;"	m	struct:__anon97
index_length	layout.h	/^	le32 index_length;		\/* Data size of the index in bytes,$/;"	m	struct:__anon95
index_record_size	volume.h	/^	u32 index_record_size;		\/* in bytes *\/$/;"	m	struct:__anon4
index_record_size_bits	volume.h	/^	u8 index_record_size_bits;	\/* log2(index_record_size) *\/$/;"	m	struct:__anon4
index_record_size_mask	volume.h	/^	u32 index_record_size_mask;	\/* index_record_size - 1 *\/$/;"	m	struct:__anon4
indexed_file	layout.h	/^			leMFT_REF indexed_file;	\/* The mft reference of the file$/;"	m	struct:__anon104::__anon105::__anon106
indexed_file	layout.h	/^			leMFT_REF indexed_file;	\/* The mft reference of the file$/;"	m	struct:__anon108::__anon109::__anon110
inherited_object_type	layout.h	/^\/* 28*\/	GUID inherited_object_type;$/;"	m	struct:__anon79
init_ntfs_fs	super.c	/^static int __init init_ntfs_fs(void)$/;"	f	file:
initialized_size	inode.h	/^	s64 initialized_size;	\/* Copy from the attribute record. *\/$/;"	m	struct:_ntfs_inode
initialized_size	layout.h	/^\/* 56*\/			sle64 initialized_size;	\/* Byte size of initialized$/;"	m	struct:__anon45::__anon46::__anon48
inode_inc_iversion	ntfs_g.h	/^static inline void inode_inc_iversion(struct inode *inode)$/;"	f
inotify_d_instantiate	ntfs_g.c	/^EXPORT_SYMBOL(inotify_d_instantiate);$/;"	v
inotify_d_instantiate	ntfs_g.c	/^void inotify_d_instantiate(struct dentry *entry, struct inode *inode)$/;"	f
instance	layout.h	/^\/* 14*\/	le16 instance;		\/* The instance of this attribute record. This$/;"	m	struct:__anon45
instance	layout.h	/^\/* 24*\/	le16 instance;		\/* If lowest_vcn = 0, the instance of the$/;"	m	struct:__anon54
instance	lockdep.h	/^	struct lockdep_map		*instance;$/;"	m	struct:held_lock	typeref:struct:held_lock::lockdep_map
ip	lockdep.h	/^	unsigned long			ip;$/;"	m	struct:lockdep_map
ir	index.h	/^	INDEX_ROOT *ir;$/;"	m	struct:__anon15
irq_context	lockdep.h	/^	u8				irq_context;$/;"	m	struct:lock_chain
irq_context	lockdep.h	/^	unsigned int irq_context:2; \/* bit 0 - soft, bit 1 - hard *\/$/;"	m	struct:held_lock
is_boot_sector_ntfs	super.c	/^static bool is_boot_sector_ntfs(const struct super_block *sb,$/;"	f	file:
is_first	attrib.h	/^	bool is_first;$/;"	m	struct:__anon14
is_in_root	index.h	/^	bool is_in_root;$/;"	m	struct:__anon15
is_vmalloc_addr	ntfs_g.h	/^static inline int is_vmalloc_addr(const void *x)$/;"	f
itype	inode.h	/^	} itype;$/;"	m	struct:_ntfs_inode	typeref:union:_ntfs_inode::__anon24
journal_id	usnjrnl.h	/^\/*0x10*\/sle64 journal_id;	\/* Current id of the transaction log. *\/$/;"	m	struct:__anon6
jump	layout.h	/^	u8  jump[3];			\/* Irrelevant (jump to boot up code).*\/$/;"	m	struct:__anon32
key	layout.h	/^	} __attribute__ ((__packed__)) key;$/;"	m	struct:__anon108	typeref:union:__anon108::__anon112
key	lockdep.h	/^	struct lock_class_key		*key;$/;"	m	struct:lockdep_map	typeref:struct:lockdep_map::lock_class_key
key	lockdep.h	/^	struct lockdep_subclass_key	*key;$/;"	m	struct:lock_class	typeref:struct:lock_class::lockdep_subclass_key
key_length	layout.h	/^	le16 key_length;	 \/* Byte size of the key value, which is in the$/;"	m	struct:__anon108
key_length	layout.h	/^\/* 10*\/	le16 key_length;	 \/* Byte size of the key value, which is in the$/;"	m	struct:__anon104
kmem_cache	ntfs_g.h	5;"	d
large_sectors	layout.h	/^	le32 large_sectors;		\/* zero *\/$/;"	m	struct:__anon31
last_access_time	layout.h	/^\/* 20*\/	sle64 last_access_time;		\/* Time this mft record was last$/;"	m	struct:__anon56
last_access_time	layout.h	/^\/* 24*\/	sle64 last_access_time;		\/* Approximate time when the file was$/;"	m	struct:__anon50
last_data_change_time	layout.h	/^\/*  8*\/	sle64 last_data_change_time;	\/* Time the data attribute was last$/;"	m	struct:__anon50
last_data_change_time	layout.h	/^\/* 10*\/	sle64 last_data_change_time;	\/* Time the data attribute was last$/;"	m	struct:__anon56
last_lsn_data_length	logfile.h	/^\/* 32*\/	le32 last_lsn_data_length;\/* Length of data of last LSN, not including$/;"	m	struct:__anon12
last_mft_change_time	layout.h	/^\/* 16*\/	sle64 last_mft_change_time;	\/* Time this mft record was last$/;"	m	struct:__anon50
last_mft_change_time	layout.h	/^\/* 18*\/	sle64 last_mft_change_time;	\/* Time this mft record was last$/;"	m	struct:__anon56
lcn	runlist.h	/^	LCN lcn;	\/* lcn = Starting logical cluster number. *\/$/;"	m	struct:__anon1
lcnbmp_ino	volume.h	/^	struct inode *lcnbmp_ino;	\/* The VFS inode of $Bitmap. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
lcnbmp_lock	volume.h	/^	struct rw_semaphore lcnbmp_lock; \/* Lock for serializing accesses to the$/;"	m	struct:__anon4	typeref:struct:__anon4::rw_semaphore
lcnbmp_mrec_lock_key	super.c	/^	lcnbmp_runlist_lock_key, lcnbmp_mrec_lock_key,$/;"	v	typeref:struct:	file:
lcnbmp_runlist_lock_key	super.c	/^	lcnbmp_runlist_lock_key, lcnbmp_mrec_lock_key,$/;"	v	typeref:struct:lock_class_key	file:
le16	types.h	/^typedef __le16 le16;$/;"	t
le16_add_cpu	ntfs_g.h	/^static inline void le16_add_cpu(__le16 *var, u16 val)$/;"	f
le32	types.h	/^typedef __le32 le32;$/;"	t
le64	types.h	/^typedef __le64 le64;$/;"	t
leLCN	types.h	/^typedef sle64 leLCN;$/;"	t
leLSN	types.h	/^typedef sle64 leLSN;$/;"	t
leMFT_REF	layout.h	/^typedef le64 leMFT_REF;$/;"	t
leUSN	types.h	/^typedef sle64 leUSN;$/;"	t
leVCN	types.h	/^typedef sle64 leVCN;$/;"	t
legal_ansi_char_array	unistr.c	/^static const u8 legal_ansi_char_array[0x40] = {$/;"	v	file:
len	dir.h	/^	u8 len;$/;"	m	struct:__anon18
length	layout.h	/^	le16 length;		 \/* Byte size of this index entry, multiple of$/;"	m	struct:__anon108
length	layout.h	/^	le32 length;	  \/* Size in bytes of this entry in $SDS stream. *\/$/;"	m	struct:__anon86
length	layout.h	/^	le32 length;	  \/* Size in bytes of this entry in $SDS stream. *\/$/;"	m	struct:__anon87
length	layout.h	/^\/*  4*\/	le16 length;		\/* Byte size of this entry (8-byte aligned). *\/$/;"	m	struct:__anon54
length	layout.h	/^\/*  4*\/	le32 length;		\/* Byte size of the resident part of the$/;"	m	struct:__anon45
length	layout.h	/^\/*  8*\/	le16 length;		 \/* Byte size of this index entry, multiple of$/;"	m	struct:__anon104
length	runlist.h	/^	s64 length;	\/* Run length in clusters. *\/$/;"	m	struct:__anon1
length	usnjrnl.h	/^\/*   0*\/le32 length;		\/* Byte size of this record (8-byte$/;"	m	struct:__anon9
limit	layout.h	/^	sle64 limit;		\/* Hard quota (-1 if not limited). *\/$/;"	m	struct:__anon100
link_count	layout.h	/^\/* 18*\/	le16 link_count;	\/* Number of hard links, i.e. the number of$/;"	m	struct:__anon37
link_count	layout.h	/^\/* 18*\/	le16 link_count;	\/* Number of hard links, i.e. the number of$/;"	m	struct:__anon38
list	mutex.h	/^	struct list_head	list;$/;"	m	struct:mutex_waiter	typeref:struct:mutex_waiter::list_head
load_and_check_logfile	super.c	/^static bool load_and_check_logfile(ntfs_volume *vol,$/;"	f	file:
load_and_init_attrdef	super.c	/^static bool load_and_init_attrdef(ntfs_volume *vol)$/;"	f	file:
load_and_init_mft_mirror	super.c	/^static bool load_and_init_mft_mirror(ntfs_volume *vol)$/;"	f	file:
load_and_init_quota	super.c	/^static bool load_and_init_quota(ntfs_volume *vol)$/;"	f	file:
load_and_init_upcase	super.c	/^static bool load_and_init_upcase(ntfs_volume *vol)$/;"	f	file:
load_and_init_usnjrnl	super.c	/^static bool load_and_init_usnjrnl(ntfs_volume *vol)$/;"	f	file:
load_attribute_list	attrib.c	/^int load_attribute_list(ntfs_volume *vol, runlist *runlist, u8 *al_start,$/;"	f
load_system_files	super.c	/^static bool load_system_files(ntfs_volume *vol)$/;"	f	file:
lock	runlist.h	/^	struct rw_semaphore lock;$/;"	m	struct:__anon2	typeref:struct:__anon2::rw_semaphore
lock_acquire	lockdep.h	312;"	d
lock_acquired	lockdep.h	360;"	d
lock_chain	lockdep.h	/^struct lock_chain {$/;"	s
lock_class	lockdep.h	/^struct lock_class {$/;"	s
lock_class_key	lockdep.h	/^struct lock_class_key { };$/;"	s
lock_class_key	lockdep.h	/^struct lock_class_key {$/;"	s
lock_class_stats	lockdep.h	/^struct lock_class_stats {$/;"	s
lock_contended	lockdep.h	359;"	d
lock_entry	lockdep.h	/^	struct list_head		lock_entry;$/;"	m	struct:lock_class	typeref:struct:lock_class::list_head
lock_list	lockdep.h	/^struct lock_list {$/;"	s
lock_map_acquire	lockdep.h	478;"	d
lock_map_acquire	lockdep.h	480;"	d
lock_map_acquire	lockdep.h	484;"	d
lock_map_release	lockdep.h	482;"	d
lock_map_release	lockdep.h	485;"	d
lock_release	lockdep.h	313;"	d
lock_set_class	lockdep.h	314;"	d
lock_set_subclass	lockdep.h	/^static inline void lock_set_subclass(struct lockdep_map *lock,$/;"	f
lock_set_subclass	lockdep.h	315;"	d
lock_time	lockdep.h	/^struct lock_time {$/;"	s
lockdep_clear_current_reclaim_state	lockdep.h	317;"	d
lockdep_depth	lockdep.h	300;"	d
lockdep_depth	lockdep.h	339;"	d
lockdep_free_key_range	lockdep.h	332;"	d
lockdep_info	lockdep.h	320;"	d
lockdep_init	lockdep.h	319;"	d
lockdep_init_map	lockdep.h	321;"	d
lockdep_map	lockdep.h	/^struct lockdep_map {$/;"	s
lockdep_off	lockdep.h	/^static inline void lockdep_off(void)$/;"	f
lockdep_on	lockdep.h	/^static inline void lockdep_on(void)$/;"	f
lockdep_reset	lockdep.h	331;"	d
lockdep_set_class	lockdep.h	252;"	d
lockdep_set_class	lockdep.h	323;"	d
lockdep_set_class_and_name	lockdep.h	254;"	d
lockdep_set_class_and_name	lockdep.h	324;"	d
lockdep_set_class_and_subclass	lockdep.h	256;"	d
lockdep_set_class_and_subclass	lockdep.h	326;"	d
lockdep_set_current_reclaim_state	lockdep.h	316;"	d
lockdep_set_subclass	lockdep.h	258;"	d
lockdep_set_subclass	lockdep.h	328;"	d
lockdep_subclass_key	lockdep.h	/^struct lockdep_subclass_key {$/;"	s
lockdep_sys_exit	lockdep.h	333;"	d
lockdep_trace_alloc	lockdep.h	318;"	d
locks_after	lockdep.h	/^	struct list_head		locks_after, locks_before;$/;"	m	struct:lock_class	typeref:struct:lock_class::list_head
locks_before	lockdep.h	/^	struct list_head		locks_after, locks_before;$/;"	m	struct:lock_class	typeref:struct:lock_class::
log_clients	logfile.h	/^\/*  8*\/	le16 log_clients;	\/* Number of log client records in the array of$/;"	m	struct:__anon12
log_page_data_offset	logfile.h	/^\/* 38*\/	le16 log_page_data_offset;\/* Offset to the start of data in a log record$/;"	m	struct:__anon12
log_page_size	logfile.h	/^\/* 20*\/	le32 log_page_size;	\/* Byte size of log file pages, has to be >=$/;"	m	struct:__anon10
log_record_header_length	logfile.h	/^\/* 36*\/	le16 log_record_header_length;\/* Byte size of the log record header.$/;"	m	struct:__anon12
logfile_ino	volume.h	/^	struct inode *logfile_ino;	\/* The VFS inode of $LogFile. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
low_part	layout.h	/^		u32 low_part;	\/* Low 32-bits. *\/$/;"	m	struct:__anon68::__anon69
lowest_valid_usn	usnjrnl.h	/^\/*0x18*\/leUSN lowest_valid_usn;	\/* Lowest valid usn in $DATA\/$J for the$/;"	m	struct:__anon6
lowest_vcn	layout.h	/^\/*  8*\/	leVCN lowest_vcn;	\/* Lowest virtual cluster number of this portion$/;"	m	struct:__anon54
lowest_vcn	layout.h	/^\/* 16*\/			leVCN lowest_vcn;\/* Lowest valid virtual cluster number$/;"	m	struct:__anon45::__anon46::__anon48
lru_list	ntfs_g.h	/^enum lru_list {$/;"	g
lsn	layout.h	/^\/*  8*\/	le64 lsn;		\/* $LogFile sequence number for this record.$/;"	m	struct:__anon37
lsn	layout.h	/^\/*  8*\/	le64 lsn;		\/* $LogFile sequence number for this record.$/;"	m	struct:__anon38
lsn	layout.h	/^\/*  8*\/	sle64 lsn;		\/* $LogFile sequence number of the last$/;"	m	struct:__anon97
magic	layout.h	/^	NTFS_RECORD_TYPE magic;	\/* A four-byte magic identifying the record$/;"	m	struct:__anon34
magic	layout.h	/^	NTFS_RECORD_TYPE magic;	\/* Magic is "INDX". *\/$/;"	m	struct:__anon97
magic	layout.h	/^	NTFS_RECORD_TYPE magic;	\/* Usually the magic is "FILE". *\/$/;"	m	struct:__anon37
magic	layout.h	/^	NTFS_RECORD_TYPE magic;	\/* Usually the magic is "FILE". *\/$/;"	m	struct:__anon38
magic	logfile.h	/^\/*  0*\/	NTFS_RECORD_TYPE magic;	\/* The magic is "RSTR". *\/$/;"	m	struct:__anon10
magic	mutex.h	/^	void			*magic;$/;"	m	struct:mutex
magic	mutex.h	/^	void			*magic;$/;"	m	struct:mutex_waiter
magicNTFS	layout.h	37;"	d
magic_BAAD	layout.h	/^	magic_BAAD = cpu_to_le32(0x44414142), \/* Failed multi sector$/;"	e	enum:__anon33
magic_CHKD	layout.h	/^	magic_CHKD = cpu_to_le32(0x444b4843), \/* Modified by chkdsk. *\/$/;"	e	enum:__anon33
magic_FILE	layout.h	/^	magic_FILE = cpu_to_le32(0x454c4946), \/* Mft entry. *\/$/;"	e	enum:__anon33
magic_HOLE	layout.h	/^	magic_HOLE = cpu_to_le32(0x454c4f48), \/* ? (NTFS 3.0+?) *\/$/;"	e	enum:__anon33
magic_INDX	layout.h	/^	magic_INDX = cpu_to_le32(0x58444e49), \/* Index buffer. *\/$/;"	e	enum:__anon33
magic_RCRD	layout.h	/^	magic_RCRD = cpu_to_le32(0x44524352), \/* Log record page. *\/$/;"	e	enum:__anon33
magic_RSTR	layout.h	/^	magic_RSTR = cpu_to_le32(0x52545352), \/* Restart page. *\/$/;"	e	enum:__anon33
magic_empty	layout.h	/^	magic_empty = cpu_to_le32(0xffffffff) \/* Record is empty. *\/$/;"	e	enum:__anon33
major_ver	layout.h	/^	u8 major_ver;		\/* Major version of the ntfs format. *\/$/;"	m	struct:__anon92
major_ver	logfile.h	/^\/* 28*\/	sle16 major_ver;	\/* Log file major version.  We only support$/;"	m	struct:__anon10
major_ver	usnjrnl.h	/^\/*   4*\/le16 major_ver;		\/* Major version of the transaction log used$/;"	m	struct:__anon9
major_ver	volume.h	/^	u8 major_ver;			\/* Ntfs major version of volume. *\/$/;"	m	struct:__anon4
map_extent_mft_record	mft.c	/^MFT_RECORD *map_extent_mft_record(ntfs_inode *base_ni, MFT_REF mref,$/;"	f
map_mft_record	mft.c	/^MFT_RECORD *map_mft_record(ntfs_inode *ni)$/;"	f
map_mft_record_page	mft.c	/^static inline MFT_RECORD *map_mft_record_page(ntfs_inode *ni)$/;"	f	file:
mapping_pairs_offset	layout.h	/^\/* 32*\/			le16 mapping_pairs_offset; \/* Byte offset from the$/;"	m	struct:__anon45::__anon46::__anon48
mark_mft_record_dirty	mft.h	/^static inline void mark_mft_record_dirty(ntfs_inode *ni)$/;"	f
mark_ntfs_record_dirty	aops.c	/^void mark_ntfs_record_dirty(struct page *page, const unsigned int ofs) {$/;"	f
mask	layout.h	/^\/*  4*\/	ACCESS_MASK mask;	\/* Access mask associated with the ACE. *\/$/;"	m	struct:__anon77
mask	layout.h	/^\/*  4*\/	ACCESS_MASK mask;	\/* Access mask associated with the ACE. *\/$/;"	m	struct:__anon79
max	lockdep.h	/^	s64				max;$/;"	m	struct:lock_time
max_size	layout.h	/^\/* 98*\/	sle64 max_size;			\/* Maximum size of attribute. *\/$/;"	m	struct:__anon42
maximum_size	usnjrnl.h	/^\/*   0*\/sle64 maximum_size;	\/* The maximum on-disk size of the $DATA\/$J$/;"	m	struct:__anon6
maximum_versions	layout.h	/^		\/* 36*\/	le32 maximum_versions;	\/* Maximum allowed versions for$/;"	m	struct:__anon50::__anon51::__anon53
media_type	layout.h	/^	u8  media_type;			\/* 0xf8 = hard disk *\/$/;"	m	struct:__anon31
mft_data_pos	volume.h	/^	s64 mft_data_pos;		\/* Mft record number at which to$/;"	m	struct:__anon4
mft_ino	volume.h	/^	struct inode *mft_ino;		\/* The VFS inode of $MFT. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
mft_lcn	layout.h	/^	sle64 mft_lcn;			\/* Cluster location of mft data. *\/$/;"	m	struct:__anon32
mft_lcn	volume.h	/^	LCN mft_lcn;			\/* Cluster location of mft data. *\/$/;"	m	struct:__anon4
mft_ni_mrec_lock_key	inode.c	/^static struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;$/;"	v	typeref:struct:	file:
mft_ni_runlist_lock_key	inode.c	/^static struct lock_class_key mft_ni_runlist_lock_key, mft_ni_mrec_lock_key;$/;"	v	typeref:struct:lock_class_key	file:
mft_no	inode.h	/^	unsigned long mft_no;	\/* Number of the mft record \/ inode. *\/$/;"	m	struct:_ntfs_inode
mft_no	inode.h	/^	unsigned long mft_no;$/;"	m	struct:__anon30
mft_record_number	layout.h	/^\/* 44*\/ le32 mft_record_number;	\/* Number of this mft record. *\/$/;"	m	struct:__anon37
mft_record_size	volume.h	/^	u32 mft_record_size;		\/* in bytes *\/$/;"	m	struct:__anon4
mft_record_size_bits	volume.h	/^	u8 mft_record_size_bits;	\/* log2(mft_record_size) *\/$/;"	m	struct:__anon4
mft_record_size_mask	volume.h	/^	u32 mft_record_size_mask;	\/* mft_record_size - 1 *\/$/;"	m	struct:__anon4
mft_reference	layout.h	/^	leMFT_REF mft_reference;\/* Mft record containing the object_id in$/;"	m	struct:__anon61
mft_reference	layout.h	/^\/* 16*\/	leMFT_REF mft_reference;\/* The reference of the mft record holding$/;"	m	struct:__anon54
mft_reference	usnjrnl.h	/^\/*   8*\/leMFT_REF mft_reference;\/* The mft reference of the file (or$/;"	m	struct:__anon9
mft_zone_end	volume.h	/^	LCN mft_zone_end;		\/* First cluster beyond the mft zone. *\/$/;"	m	struct:__anon4
mft_zone_multiplier	volume.h	/^	u8 mft_zone_multiplier;		\/* Initial mft zone multiplier. *\/$/;"	m	struct:__anon4
mft_zone_pos	volume.h	/^	LCN mft_zone_pos;		\/* Current position in the mft zone. *\/$/;"	m	struct:__anon4
mft_zone_start	volume.h	/^	LCN mft_zone_start;		\/* First cluster of the mft zone. *\/$/;"	m	struct:__anon4
mftbmp_ino	volume.h	/^	struct inode *mftbmp_ino;	\/* Attribute inode for $MFT\/$BITMAP. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
mftbmp_lock	volume.h	/^	struct rw_semaphore mftbmp_lock; \/* Lock for serializing accesses to the$/;"	m	struct:__anon4	typeref:struct:__anon4::rw_semaphore
mftbmp_mrec_lock_key	super.c	/^	mftbmp_runlist_lock_key, mftbmp_mrec_lock_key;$/;"	v	typeref:struct:	file:
mftbmp_runlist_lock_key	super.c	/^	mftbmp_runlist_lock_key, mftbmp_mrec_lock_key;$/;"	v	typeref:struct:	file:
mftmirr_ino	volume.h	/^	struct inode *mftmirr_ino;	\/* The VFS inode of $MFTMirr. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
mftmirr_lcn	layout.h	/^	sle64 mftmirr_lcn;		\/* Cluster location of copy of mft. *\/$/;"	m	struct:__anon32
mftmirr_lcn	volume.h	/^	LCN mftmirr_lcn;		\/* Cluster location of copy of mft. *\/$/;"	m	struct:__anon4
mftmirr_size	volume.h	/^	int mftmirr_size;		\/* Size of mft mirror in mft records. *\/$/;"	m	struct:__anon4
might_lock	lockdep.h	489;"	d
might_lock	lockdep.h	502;"	d
might_lock_read	lockdep.h	495;"	d
might_lock_read	lockdep.h	503;"	d
min	lockdep.h	/^	s64				min;$/;"	m	struct:lock_time
min_size	layout.h	/^\/* 90*\/	sle64 min_size;			\/* Optional minimum attribute size. *\/$/;"	m	struct:__anon42
minor_ver	layout.h	/^	u8 minor_ver;		\/* Minor version of the ntfs format. *\/$/;"	m	struct:__anon92
minor_ver	logfile.h	/^\/* 26*\/	sle16 minor_ver;	\/* Log file minor version.  Only check if major$/;"	m	struct:__anon10
minor_ver	usnjrnl.h	/^\/*   6*\/le16 minor_ver;		\/* Minor version of the transaction log used$/;"	m	struct:__anon9
minor_ver	volume.h	/^	u8 minor_ver;			\/* Ntfs minor version of volume. *\/$/;"	m	struct:__anon4
mrec	attrib.h	/^	MFT_RECORD *mrec;$/;"	m	struct:__anon14
mrec_lock	inode.h	/^	struct mutex mrec_lock;	\/* Lock for serializing access to the$/;"	m	struct:_ntfs_inode	typeref:struct:_ntfs_inode::mutex
mref	dir.h	/^	MFT_REF mref;$/;"	m	struct:__anon18
mutex	mutex.h	/^struct mutex {$/;"	s
mutex	ntfs_g.h	33;"	d
mutex_acquire	lockdep.h	451;"	d
mutex_acquire	lockdep.h	453;"	d
mutex_acquire	lockdep.h	457;"	d
mutex_destroy	mutex.h	90;"	d
mutex_destroy	ntfs_g.h	29;"	d
mutex_destroy	ntfs_g.h	38;"	d
mutex_init	mutex.h	84;"	d
mutex_init	ntfs_g.h	28;"	d
mutex_is_locked	mutex.h	/^static inline int mutex_is_locked(struct mutex *lock)$/;"	f
mutex_lock	mutex.h	135;"	d
mutex_lock	ntfs_g.h	30;"	d
mutex_lock_interruptible	mutex.h	136;"	d
mutex_lock_interruptible_nested	mutex.h	144;"	d
mutex_lock_killable	mutex.h	137;"	d
mutex_lock_killable_nested	mutex.h	145;"	d
mutex_lock_nested	mutex.h	143;"	d
mutex_release	lockdep.h	455;"	d
mutex_release	lockdep.h	458;"	d
mutex_trylock	ntfs_g.h	32;"	d
mutex_unlock	ntfs_g.h	31;"	d
mutex_waiter	mutex.h	/^struct mutex_waiter {$/;"	s
name	dir.h	/^	ntfschar name[0];$/;"	m	struct:__anon18
name	inode.h	/^	ntfschar *name;		\/* Attribute name of this fake inode. *\/$/;"	m	struct:_ntfs_inode
name	inode.h	/^	ntfschar *name;$/;"	m	struct:__anon30
name	layout.h	/^	ntfschar name[0];	\/* The name of the volume in Unicode. *\/$/;"	m	struct:__anon90
name	layout.h	/^\/*  0*\/	ntfschar name[0x40];		\/* Unicode name of the attribute. Zero$/;"	m	struct:__anon42
name	layout.h	/^\/* 26*\/	ntfschar name[0];	\/* Use when creating only. When reading use$/;"	m	struct:__anon54
name	lockdep.h	/^	const char			*name;$/;"	m	struct:lock_class
name	lockdep.h	/^	const char			*name;$/;"	m	struct:lockdep_map
name	mutex.h	/^	const char 		*name;$/;"	m	struct:mutex
name_len	inode.h	/^	u32 name_len;		\/* Attribute name length of this fake inode. *\/$/;"	m	struct:_ntfs_inode
name_len	inode.h	/^	u32 name_len;$/;"	m	struct:__anon30
name_length	layout.h	/^\/*  6*\/	u8 name_length;		\/* Size in Unicode chars of the name of the$/;"	m	struct:__anon54
name_length	layout.h	/^\/*  9*\/	u8 name_length;		\/* Unicode character size of name of attribute.$/;"	m	struct:__anon45
name_offset	layout.h	/^\/*  7*\/	u8 name_offset;		\/* Byte offset to beginning of attribute name$/;"	m	struct:__anon54
name_offset	layout.h	/^\/* 10*\/	le16 name_offset;	\/* If name_length != 0, the byte offset to the$/;"	m	struct:__anon45
name_version	lockdep.h	/^	int				name_version;$/;"	m	struct:lock_class
need_ea_count	layout.h	/^	le16 need_ea_count;	\/* The number of extended attributes which have$/;"	m	struct:__anon116
nest_lock	lockdep.h	/^	struct lockdep_map		*nest_lock;$/;"	m	struct:held_lock	typeref:struct:held_lock::lockdep_map
next_attr_instance	layout.h	/^\/* 40*\/	le16 next_attr_instance;\/* The instance number that will be assigned to$/;"	m	struct:__anon37
next_attr_instance	layout.h	/^\/* 40*\/	le16 next_attr_instance;\/* The instance number that will be assigned to$/;"	m	struct:__anon38
next_client	logfile.h	/^\/* 18*\/	le16 next_client;	\/* The offset to the next log client record in$/;"	m	struct:__anon13
next_entry_offset	layout.h	/^	le32 next_entry_offset;	\/* Offset to the next EA_ATTR. *\/$/;"	m	struct:__anon118
nls_map	volume.h	/^	struct nls_table *nls_map;$/;"	m	struct:__anon4	typeref:struct:__anon4::nls_table
non_resident	layout.h	/^		} __attribute__ ((__packed__)) non_resident;$/;"	m	union:__anon45::__anon46	typeref:struct:__anon45::__anon46::__anon48
non_resident	layout.h	/^\/*  8*\/	u8 non_resident;	\/* If 0, attribute is resident.$/;"	m	struct:__anon45
nr	lockdep.h	/^	unsigned long			nr;$/;"	m	struct:lock_time
nr_blocks	volume.h	/^	LCN nr_blocks;			\/* Number of sb->s_blocksize bytes$/;"	m	struct:__anon4
nr_bounce_types	lockdep.h	/^	nr_bounce_types,$/;"	e	enum:bounce_type
nr_clusters	volume.h	/^	LCN nr_clusters;		\/* Volume size in clusters == number of$/;"	m	struct:__anon4
nr_extents	inode.h	/^	s32 nr_extents;	\/* For a base mft record, the number of attached extent$/;"	m	struct:_ntfs_inode
ntfs-objs	Makefile	/^ntfs-objs := aops.o attrib.o collate.o compress.o debug.o dir.o file.o \\$/;"	m
ntfs2utc	time.h	/^static inline struct timespec ntfs2utc(const sle64 time)$/;"	f
ntfs_alloc_big_inode	inode.c	/^struct inode *ntfs_alloc_big_inode(struct super_block *sb)$/;"	f
ntfs_alloc_extent_inode	inode.c	/^static inline ntfs_inode *ntfs_alloc_extent_inode(void)$/;"	f	file:
ntfs_aops	aops.c	/^const struct address_space_operations ntfs_aops = {$/;"	v	typeref:struct:address_space_operations
ntfs_are_names_equal	unistr.c	/^bool ntfs_are_names_equal(const ntfschar *s1, size_t s1_len,$/;"	f
ntfs_are_rl_mergeable	runlist.c	/^static inline bool ntfs_are_rl_mergeable(runlist_element *dst,$/;"	f	file:
ntfs_attr	inode.h	/^} ntfs_attr;$/;"	t	typeref:struct:__anon30
ntfs_attr_can_be_non_resident	attrib.c	/^int ntfs_attr_can_be_non_resident(const ntfs_volume *vol, const ATTR_TYPE type)$/;"	f
ntfs_attr_can_be_resident	attrib.c	/^int ntfs_attr_can_be_resident(const ntfs_volume *vol, const ATTR_TYPE type)$/;"	f
ntfs_attr_ctx_cache	super.c	/^struct kmem_cache *ntfs_attr_ctx_cache;$/;"	v	typeref:struct:kmem_cache
ntfs_attr_ctx_cache_name	super.c	/^static const char ntfs_attr_ctx_cache_name[] = "ntfs_attr_ctx_cache";$/;"	v	file:
ntfs_attr_extend_allocation	attrib.c	/^s64 ntfs_attr_extend_allocation(ntfs_inode *ni, s64 new_alloc_size,$/;"	f
ntfs_attr_extend_initialized	file.c	/^static int ntfs_attr_extend_initialized(ntfs_inode *ni, const s64 new_init_size,$/;"	f	file:
ntfs_attr_find	attrib.c	/^static int ntfs_attr_find(const ATTR_TYPE type, const ntfschar *name,$/;"	f	file:
ntfs_attr_find_in_attrdef	attrib.c	/^static ATTR_DEF *ntfs_attr_find_in_attrdef(const ntfs_volume *vol,$/;"	f	file:
ntfs_attr_find_vcn_nolock	attrib.c	/^runlist_element *ntfs_attr_find_vcn_nolock(ntfs_inode *ni, const VCN vcn,$/;"	f
ntfs_attr_get_search_ctx	attrib.c	/^ntfs_attr_search_ctx *ntfs_attr_get_search_ctx(ntfs_inode *ni, MFT_RECORD *mrec)$/;"	f
ntfs_attr_iget	inode.c	/^struct inode *ntfs_attr_iget(struct inode *base_vi, ATTR_TYPE type,$/;"	f
ntfs_attr_init_search_ctx	attrib.c	/^static inline void ntfs_attr_init_search_ctx(ntfs_attr_search_ctx *ctx,$/;"	f	file:
ntfs_attr_lookup	attrib.c	/^int ntfs_attr_lookup(const ATTR_TYPE type, const ntfschar *name,$/;"	f
ntfs_attr_make_non_resident	attrib.c	/^int ntfs_attr_make_non_resident(ntfs_inode *ni, const u32 data_size)$/;"	f
ntfs_attr_put_search_ctx	attrib.c	/^void ntfs_attr_put_search_ctx(ntfs_attr_search_ctx *ctx)$/;"	f
ntfs_attr_record_resize	attrib.c	/^int ntfs_attr_record_resize(MFT_RECORD *m, ATTR_RECORD *a, u32 new_size)$/;"	f
ntfs_attr_reinit_search_ctx	attrib.c	/^void ntfs_attr_reinit_search_ctx(ntfs_attr_search_ctx *ctx)$/;"	f
ntfs_attr_search_ctx	attrib.h	/^} ntfs_attr_search_ctx;$/;"	t	typeref:struct:__anon14
ntfs_attr_set	attrib.c	/^int ntfs_attr_set(ntfs_inode *ni, const s64 ofs, const s64 cnt, const u8 val)$/;"	f
ntfs_attr_size	attrib.h	/^static inline s64 ntfs_attr_size(const ATTR_RECORD *a)$/;"	f
ntfs_attr_size_bounds_check	attrib.c	/^int ntfs_attr_size_bounds_check(const ntfs_volume *vol, const ATTR_TYPE type,$/;"	f
ntfs_attr_vcn_to_lcn_nolock	attrib.c	/^LCN ntfs_attr_vcn_to_lcn_nolock(ntfs_inode *ni, const VCN vcn,$/;"	f
ntfs_attrs_walk	namei.c	/^static __inline__ int ntfs_attrs_walk(ntfs_attr_search_ctx *ctx)$/;"	f	file:
ntfs_big_inode_cache	super.c	/^struct kmem_cache *ntfs_big_inode_cache;$/;"	v	typeref:struct:kmem_cache
ntfs_big_inode_cache_name	super.c	/^static const char ntfs_big_inode_cache_name[] = "ntfs_big_inode_cache";$/;"	v	file:
ntfs_big_inode_init_once	super.c	/^static void ntfs_big_inode_init_once(void *foo, kmem_cache_t *cachep,$/;"	f	file:
ntfs_bitmap_clear_bit	bitmap.h	/^static inline int ntfs_bitmap_clear_bit(struct inode *vi, const s64 bit)$/;"	f
ntfs_bitmap_clear_run	bitmap.h	/^static inline int ntfs_bitmap_clear_run(struct inode *vi, const s64 start_bit,$/;"	f
ntfs_bitmap_set_bit	bitmap.h	/^static inline int ntfs_bitmap_set_bit(struct inode *vi, const s64 bit)$/;"	f
ntfs_bitmap_set_bits_in_run	bitmap.h	/^static inline int ntfs_bitmap_set_bits_in_run(struct inode *vi,$/;"	f
ntfs_bitmap_set_run	bitmap.h	/^static inline int ntfs_bitmap_set_run(struct inode *vi, const s64 start_bit,$/;"	f
ntfs_check_and_load_restart_page	logfile.c	/^static int ntfs_check_and_load_restart_page(struct inode *vi,$/;"	f	file:
ntfs_check_log_client_array	logfile.c	/^static bool ntfs_check_log_client_array(struct inode *vi,$/;"	f	file:
ntfs_check_logfile	logfile.c	/^bool ntfs_check_logfile(struct inode *log_vi, RESTART_PAGE_HEADER **rp)$/;"	f
ntfs_check_restart_area	logfile.c	/^static bool ntfs_check_restart_area(struct inode *vi, RESTART_PAGE_HEADER *rp)$/;"	f	file:
ntfs_check_restart_page_header	logfile.c	/^static bool ntfs_check_restart_page_header(struct inode *vi,$/;"	f	file:
ntfs_clear_big_inode	inode.c	/^void ntfs_clear_big_inode(struct inode *vi)$/;"	f
ntfs_clear_extent_inode	inode.c	/^void ntfs_clear_extent_inode(ntfs_inode *ni)$/;"	f
ntfs_clear_volume_flags	super.c	/^static inline int ntfs_clear_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)$/;"	f	file:
ntfs_cluster_alloc	lcnalloc.c	/^runlist_element *ntfs_cluster_alloc(ntfs_volume *vol, const VCN start_vcn,$/;"	f
ntfs_cluster_free	lcnalloc.h	/^static inline s64 ntfs_cluster_free(ntfs_inode *ni, const VCN start_vcn,$/;"	f
ntfs_cluster_free_from_rl	lcnalloc.h	/^static inline int ntfs_cluster_free_from_rl(ntfs_volume *vol,$/;"	f
ntfs_cluster_free_from_rl_nolock	lcnalloc.c	/^int ntfs_cluster_free_from_rl_nolock(ntfs_volume *vol,$/;"	f
ntfs_collate	collate.c	/^int ntfs_collate(ntfs_volume *vol, COLLATION_RULE cr,$/;"	f
ntfs_collate_binary	collate.c	/^static int ntfs_collate_binary(ntfs_volume *vol,$/;"	f	file:
ntfs_collate_func_t	collate.c	/^typedef int (*ntfs_collate_func_t)(ntfs_volume *, const void *, const int,$/;"	t	file:
ntfs_collate_names	unistr.c	/^int ntfs_collate_names(const ntfschar *name1, const u32 name1_len,$/;"	f
ntfs_collate_ntofs_ulong	collate.c	/^static int ntfs_collate_ntofs_ulong(ntfs_volume *vol,$/;"	f	file:
ntfs_commit_inode	inode.h	/^static inline void ntfs_commit_inode(struct inode *vi)$/;"	f
ntfs_commit_pages_after_non_resident_write	file.c	/^static inline int ntfs_commit_pages_after_non_resident_write($/;"	f	file:
ntfs_commit_pages_after_write	file.c	/^static int ntfs_commit_pages_after_write(struct page **pages,$/;"	f	file:
ntfs_compression_buffer	compress.c	/^static u8 *ntfs_compression_buffer = NULL;$/;"	v	file:
ntfs_compression_constants	compress.c	/^} ntfs_compression_constants;$/;"	t	typeref:enum:__anon19	file:
ntfs_copy_from_user	file.c	/^static inline size_t ntfs_copy_from_user(struct page **pages,$/;"	f	file:
ntfs_copy_from_user_iovec	file.c	/^static inline size_t ntfs_copy_from_user_iovec(struct page **pages,$/;"	f	file:
ntfs_create	namei.c	/^ntfs_inode *ntfs_create(ntfs_inode *dir_ni, ntfschar *name, u8 name_len,$/;"	f
ntfs_debug	debug.h	43;"	d
ntfs_debug	debug.h	50;"	d
ntfs_debug_dump_runlist	debug.c	/^void ntfs_debug_dump_runlist(const runlist_element *rl)$/;"	f
ntfs_debug_dump_runlist	debug.h	51;"	d
ntfs_decompress	compress.c	/^static int ntfs_decompress(struct page *dest_pages[], int *dest_index,$/;"	f	file:
ntfs_delete	namei.c	/^int ntfs_delete(ntfs_inode *ni, ntfs_inode *dir_ni )$/;"	f
ntfs_destroy_big_inode	inode.c	/^void ntfs_destroy_big_inode(struct inode *inode)$/;"	f
ntfs_destroy_extent_inode	inode.c	/^static void ntfs_destroy_extent_inode(ntfs_inode *ni)$/;"	f	file:
ntfs_dir_fsync	dir.c	/^static int ntfs_dir_fsync(struct file *filp, struct dentry *dentry,$/;"	f	file:
ntfs_dir_inode_ops	namei.c	/^const struct inode_operations ntfs_dir_inode_ops = {$/;"	v	typeref:struct:inode_operations
ntfs_dir_open	dir.c	/^static int ntfs_dir_open(struct inode *vi, struct file *filp)$/;"	f	file:
ntfs_dir_ops	dir.c	/^const struct file_operations ntfs_dir_ops = {$/;"	v	typeref:struct:file_operations
ntfs_do_collate0x0	collate.c	/^static ntfs_collate_func_t ntfs_do_collate0x0[3] = {$/;"	v	file:
ntfs_do_collate0x1	collate.c	/^static ntfs_collate_func_t ntfs_do_collate0x1[4] = {$/;"	v	file:
ntfs_empty_file_ops	file.c	/^const struct file_operations ntfs_empty_file_ops = {};$/;"	v	typeref:struct:file_operations
ntfs_empty_inode_ops	file.c	/^const struct inode_operations ntfs_empty_inode_ops = {};$/;"	v	typeref:struct:inode_operations
ntfs_empty_logfile	logfile.c	/^bool ntfs_empty_logfile(struct inode *log_vi)$/;"	f
ntfs_end_buffer_async_read	aops.c	/^static void ntfs_end_buffer_async_read(struct buffer_head *bh, int uptodate)$/;"	f	file:
ntfs_error	debug.h	61;"	d
ntfs_error_attr	debug.h	64;"	d
ntfs_extent_mft_record_free	mft.c	/^int ntfs_extent_mft_record_free(ntfs_inode *ni, MFT_RECORD *m)$/;"	f
ntfs_external_attr_find	attrib.c	/^static int ntfs_external_attr_find(const ATTR_TYPE type,$/;"	f	file:
ntfs_fault_in_pages_readable	file.c	/^static inline void ntfs_fault_in_pages_readable(const char __user *uaddr,$/;"	f	file:
ntfs_fault_in_pages_readable_iovec	file.c	/^static inline void ntfs_fault_in_pages_readable_iovec(const struct iovec *iov,$/;"	f	file:
ntfs_ffs	ntfs.h	/^static inline int ntfs_ffs(int x)$/;"	f
ntfs_file_aio_write	file.c	/^static ssize_t ntfs_file_aio_write(struct kiocb *iocb, const char __user *buf,$/;"	f	file:
ntfs_file_aio_write_nolock	file.c	/^static ssize_t ntfs_file_aio_write_nolock(struct kiocb *iocb,$/;"	f	file:
ntfs_file_buffered_write	file.c	/^static ssize_t ntfs_file_buffered_write(struct kiocb *iocb,$/;"	f	file:
ntfs_file_compare_values	unistr.c	/^int ntfs_file_compare_values(FILE_NAME_ATTR *file_name_attr1,$/;"	f
ntfs_file_fsync	file.c	/^static int ntfs_file_fsync(struct file *filp, struct dentry *dentry,$/;"	f	file:
ntfs_file_inode_ops	file.c	/^const struct inode_operations ntfs_file_inode_ops = {$/;"	v	typeref:struct:inode_operations
ntfs_file_open	file.c	/^static int ntfs_file_open(struct inode *vi, struct file *filp)$/;"	f	file:
ntfs_file_ops	file.c	/^const struct file_operations ntfs_file_ops = {$/;"	v	typeref:struct:file_operations
ntfs_file_upcase_value	unistr.c	/^void ntfs_file_upcase_value(FILE_NAME_ATTR *file_name_attr,$/;"	f
ntfs_file_write	file.c	/^static ssize_t ntfs_file_write(struct file *file, const char __user *buf,$/;"	f	file:
ntfs_file_writev	file.c	/^static ssize_t ntfs_file_writev(struct file *file, const struct iovec *iov,$/;"	f	file:
ntfs_fill_super	super.c	/^static int ntfs_fill_super(struct super_block *sb, void *opt, const int silent)$/;"	f	file:
ntfs_filldir	dir.c	/^static inline int ntfs_filldir(ntfs_volume *vol, loff_t fpos,$/;"	f	file:
ntfs_flush_dcache_pages	file.c	/^static inline void ntfs_flush_dcache_pages(struct page **pages,$/;"	f	file:
ntfs_free	malloc.h	/^static inline void ntfs_free(void *addr)$/;"	f
ntfs_fs_type	super.c	/^static struct file_system_type ntfs_fs_type = {$/;"	v	typeref:struct:file_system_type	file:
ntfs_get_nr_significant_bytes	runlist.c	/^static inline int ntfs_get_nr_significant_bytes(const s64 n)$/;"	f	file:
ntfs_get_sb	super.c	/^struct super_block *ntfs_get_sb(struct file_system_type *fs_type,$/;"	f
ntfs_get_size_for_mapping_pairs	runlist.c	/^int ntfs_get_size_for_mapping_pairs(const ntfs_volume *vol,$/;"	f
ntfs_ie_add	namei.c	/^static int ntfs_ie_add(ntfs_index_context *icx, INDEX_ENTRY *ie)$/;"	f	file:
ntfs_ie_delete	namei.c	/^static void ntfs_ie_delete(INDEX_HEADER *ih, INDEX_ENTRY *ie)$/;"	f	file:
ntfs_ie_end	namei.c	/^static int ntfs_ie_end(INDEX_ENTRY *ie)$/;"	f	file:
ntfs_ie_get_end	namei.c	/^static u8 *ntfs_ie_get_end(INDEX_HEADER *ih)$/;"	f	file:
ntfs_ie_get_first	namei.c	/^static INDEX_ENTRY *ntfs_ie_get_first(INDEX_HEADER *ih)$/;"	f	file:
ntfs_ie_get_next	namei.c	/^static INDEX_ENTRY *ntfs_ie_get_next(INDEX_ENTRY *ie)$/;"	f	file:
ntfs_ie_insert	namei.c	/^static void ntfs_ie_insert(INDEX_HEADER *ih, INDEX_ENTRY *ie, INDEX_ENTRY *pos)$/;"	f	file:
ntfs_iget	inode.c	/^struct inode *ntfs_iget(struct super_block *sb, unsigned long mft_no)$/;"	f
ntfs_ih_numof_entries	namei.c	/^static int ntfs_ih_numof_entries(INDEX_HEADER *ih)$/;"	f	file:
ntfs_ih_one_entry	namei.c	/^static int ntfs_ih_one_entry(INDEX_HEADER *ih)$/;"	f	file:
ntfs_index_add_filename	namei.c	/^int ntfs_index_add_filename(ntfs_inode *ni, FILE_NAME_ATTR *fn, MFT_REF mref)$/;"	f
ntfs_index_context	index.h	/^} ntfs_index_context;$/;"	t	typeref:struct:__anon15
ntfs_index_ctx_cache	super.c	/^struct kmem_cache *ntfs_index_ctx_cache;$/;"	v	typeref:struct:kmem_cache
ntfs_index_ctx_cache_name	super.c	/^static const char ntfs_index_ctx_cache_name[] = "ntfs_index_ctx_cache";$/;"	v	file:
ntfs_index_ctx_get	index.c	/^ntfs_index_context *ntfs_index_ctx_get(ntfs_inode *idx_ni)$/;"	f
ntfs_index_ctx_get_I30	namei.c	/^ntfs_index_context * ntfs_index_ctx_get_I30(ntfs_inode *idx_ni)$/;"	f
ntfs_index_ctx_put	index.c	/^void ntfs_index_ctx_put(ntfs_index_context *ictx)$/;"	f
ntfs_index_ctx_put_I30	namei.c	/^void ntfs_index_ctx_put_I30(ntfs_index_context *ictx)$/;"	f
ntfs_index_entry_flush_dcache_page	index.h	/^static inline void ntfs_index_entry_flush_dcache_page(ntfs_index_context *ictx)$/;"	f
ntfs_index_entry_mark_dirty	index.h	/^static inline void ntfs_index_entry_mark_dirty(ntfs_index_context *ictx)$/;"	f
ntfs_index_iget	inode.c	/^struct inode *ntfs_index_iget(struct inode *base_vi, ntfschar *name,$/;"	f
ntfs_index_lookup	index.c	/^int ntfs_index_lookup(const void *key, const int key_len,$/;"	f
ntfs_index_remove	namei.c	/^int ntfs_index_remove(ntfs_inode *ni, const void *key, const int keylen)$/;"	f
ntfs_index_rm	namei.c	/^static int ntfs_index_rm(ntfs_index_context *icx)$/;"	f	file:
ntfs_init_big_inode	inode.h	/^static inline void ntfs_init_big_inode(struct inode *vi)$/;"	f
ntfs_init_locked_inode	inode.c	/^static int ntfs_init_locked_inode(struct inode *vi, ntfs_attr *na)$/;"	f	file:
ntfs_init_runlist	runlist.h	/^static inline void ntfs_init_runlist(runlist *rl)$/;"	f
ntfs_ino	attrib.h	/^	ntfs_inode *ntfs_ino;$/;"	m	struct:__anon14
ntfs_inode	inode.h	/^	ntfs_inode ntfs_inode;$/;"	m	struct:__anon29
ntfs_inode	inode.h	/^typedef struct _ntfs_inode ntfs_inode;$/;"	t	typeref:struct:_ntfs_inode
ntfs_inode_cache	super.c	/^struct kmem_cache *ntfs_inode_cache;$/;"	v	typeref:struct:kmem_cache
ntfs_inode_cache_name	super.c	/^static const char ntfs_inode_cache_name[] = "ntfs_inode_cache";$/;"	v	file:
ntfs_inode_state_bits	inode.h	/^} ntfs_inode_state_bits;$/;"	t	typeref:enum:__anon28
ntfs_ir_make_space	namei.c	/^static int ntfs_ir_make_space(ntfs_index_context *icx, int data_size)$/;"	f	file:
ntfs_ir_truncate	namei.c	/^static int ntfs_ir_truncate(ntfs_index_context *icx, int data_size)$/;"	f	file:
ntfs_is_baad_record	layout.h	168;"	d
ntfs_is_baad_recordp	layout.h	169;"	d
ntfs_is_chkd_record	layout.h	165;"	d
ntfs_is_chkd_recordp	layout.h	166;"	d
ntfs_is_collation_rule_supported	collate.h	/^static inline bool ntfs_is_collation_rule_supported(COLLATION_RULE cr) {$/;"	f
ntfs_is_empty_record	layout.h	171;"	d
ntfs_is_empty_recordp	layout.h	172;"	d
ntfs_is_extended_system_file	inode.c	/^static int ntfs_is_extended_system_file(ntfs_attr_search_ctx *ctx)$/;"	f	file:
ntfs_is_file_record	layout.h	151;"	d
ntfs_is_file_recordp	layout.h	152;"	d
ntfs_is_hole_record	layout.h	157;"	d
ntfs_is_hole_recordp	layout.h	158;"	d
ntfs_is_indx_record	layout.h	155;"	d
ntfs_is_indx_recordp	layout.h	156;"	d
ntfs_is_logfile_clean	logfile.c	/^bool ntfs_is_logfile_clean(struct inode *log_vi, const RESTART_PAGE_HEADER *rp)$/;"	f
ntfs_is_magic	layout.h	140;"	d
ntfs_is_magicp	layout.h	146;"	d
ntfs_is_mft_record	layout.h	153;"	d
ntfs_is_mft_recordp	layout.h	154;"	d
ntfs_is_rcrd_record	layout.h	162;"	d
ntfs_is_rcrd_recordp	layout.h	163;"	d
ntfs_is_rstr_record	layout.h	160;"	d
ntfs_is_rstr_recordp	layout.h	161;"	d
ntfs_lock	super.c	/^DEFINE_MUTEX(ntfs_lock);$/;"	v
ntfs_lookup	namei.c	/^static struct dentry *ntfs_lookup(struct inode *dir_ino, struct dentry *dent,$/;"	f	file:
ntfs_lookup_inode_by_key	dir.c	/^int ntfs_lookup_inode_by_key (const void *key, const int key_len, ntfs_index_context *ictx)$/;"	f
ntfs_lookup_inode_by_name	dir.c	/^MFT_REF ntfs_lookup_inode_by_name(ntfs_inode *dir_ni, const ntfschar *uname,$/;"	f
ntfs_malloc_nofs	malloc.h	/^static inline void *ntfs_malloc_nofs(unsigned long size)$/;"	f
ntfs_malloc_nofs_nofail	malloc.h	/^static inline void *ntfs_malloc_nofs_nofail(unsigned long size)$/;"	f
ntfs_map_page	aops.h	/^static inline struct page *ntfs_map_page(struct address_space *mapping,$/;"	f
ntfs_map_runlist	attrib.c	/^int ntfs_map_runlist(ntfs_inode *ni, VCN vcn)$/;"	f
ntfs_map_runlist_nolock	attrib.c	/^int ntfs_map_runlist_nolock(ntfs_inode *ni, VCN vcn, ntfs_attr_search_ctx *ctx)$/;"	f
ntfs_mapping_pairs_build	runlist.c	/^int ntfs_mapping_pairs_build(const ntfs_volume *vol, s8 *dst,$/;"	f
ntfs_mapping_pairs_decompress	runlist.c	/^runlist_element *ntfs_mapping_pairs_decompress(const ntfs_volume *vol,$/;"	f
ntfs_mark_quotas_out_of_date	quota.c	/^bool ntfs_mark_quotas_out_of_date(ntfs_volume *vol)$/;"	f
ntfs_may_write_mft_record	mft.c	/^bool ntfs_may_write_mft_record(ntfs_volume *vol, const unsigned long mft_no,$/;"	f
ntfs_mft_bitmap_extend_allocation_nolock	mft.c	/^static int ntfs_mft_bitmap_extend_allocation_nolock(ntfs_volume *vol)$/;"	f	file:
ntfs_mft_bitmap_extend_initialized_nolock	mft.c	/^static int ntfs_mft_bitmap_extend_initialized_nolock(ntfs_volume *vol)$/;"	f	file:
ntfs_mft_bitmap_find_and_alloc_free_rec_nolock	mft.c	/^static int ntfs_mft_bitmap_find_and_alloc_free_rec_nolock(ntfs_volume *vol,$/;"	f	file:
ntfs_mft_data_extend_allocation_nolock	mft.c	/^static int ntfs_mft_data_extend_allocation_nolock(ntfs_volume *vol)$/;"	f	file:
ntfs_mft_record_alloc	mft.c	/^ntfs_inode *ntfs_mft_record_alloc(ntfs_volume *vol, const int mode,$/;"	f
ntfs_mft_record_format	mft.c	/^static int ntfs_mft_record_format(const ntfs_volume *vol, const s64 mft_no)$/;"	f	file:
ntfs_mft_record_free	mft.c	/^int ntfs_mft_record_free(ntfs_volume *vol, ntfs_inode *ni,MFT_RECORD* mrec)$/;"	f
ntfs_mft_record_layout	mft.c	/^static int ntfs_mft_record_layout(const ntfs_volume *vol, const s64 mft_no,$/;"	f	file:
ntfs_mst_aops	aops.c	/^const struct address_space_operations ntfs_mst_aops = {$/;"	v	typeref:struct:address_space_operations
ntfs_name	dir.h	/^} __attribute__ ((__packed__)) ntfs_name;$/;"	t	typeref:struct:__anon18
ntfs_name_cache	super.c	/^struct kmem_cache *ntfs_name_cache;$/;"	v	typeref:struct:kmem_cache
ntfs_name_cache_name	super.c	/^static const char ntfs_name_cache_name[] = "ntfs_name_cache";$/;"	v	file:
ntfs_new_extent_inode	inode.c	/^inline ntfs_inode *ntfs_new_extent_inode(struct super_block *sb,$/;"	f
ntfs_nlstoucs	unistr.c	/^int ntfs_nlstoucs(const ntfs_volume *vol, const char *ins,$/;"	f
ntfs_nr_compression_users	super.c	/^static unsigned long ntfs_nr_compression_users;$/;"	v	file:
ntfs_nr_upcase_users	super.c	/^static unsigned long ntfs_nr_upcase_users = 0;$/;"	v	file:
ntfs_please_email	mft.c	/^static const char *ntfs_please_email = "Please email "$/;"	v	file:
ntfs_prepare_pages_for_non_resident_write	file.c	/^static int ntfs_prepare_pages_for_non_resident_write(struct page **pages,$/;"	f	file:
ntfs_put_super	super.c	/^static void ntfs_put_super(struct super_block *sb)$/;"	f	file:
ntfs_read_block	aops.c	/^static int ntfs_read_block(struct page *page)$/;"	f	file:
ntfs_read_compressed_block	compress.c	/^int ntfs_read_compressed_block(struct page *page)$/;"	f
ntfs_read_inode_mount	inode.c	/^int ntfs_read_inode_mount(struct inode *vi)$/;"	f
ntfs_read_locked_attr_inode	inode.c	/^static int ntfs_read_locked_attr_inode(struct inode *base_vi, struct inode *vi)$/;"	f	file:
ntfs_read_locked_index_inode	inode.c	/^static int ntfs_read_locked_index_inode(struct inode *base_vi, struct inode *vi)$/;"	f	file:
ntfs_read_locked_inode	inode.c	/^static int ntfs_read_locked_inode(struct inode *vi)$/;"	f	file:
ntfs_readdir	dir.c	/^static int ntfs_readdir(struct file *filp, void *dirent, filldir_t filldir)$/;"	f	file:
ntfs_readpage	aops.c	/^static int ntfs_readpage(struct file *file, struct page *page)$/;"	f	file:
ntfs_remount	super.c	/^static int ntfs_remount(struct super_block *sb, int *flags, char *opt)$/;"	f	file:
ntfs_resident_attr_value_resize	attrib.c	/^int ntfs_resident_attr_value_resize(MFT_RECORD *m, ATTR_RECORD *a,$/;"	f
ntfs_rl_append	runlist.c	/^static inline runlist_element *ntfs_rl_append(runlist_element *dst,$/;"	f	file:
ntfs_rl_find_vcn_nolock	runlist.c	/^runlist_element *ntfs_rl_find_vcn_nolock(runlist_element *rl, const VCN vcn)$/;"	f
ntfs_rl_insert	runlist.c	/^static inline runlist_element *ntfs_rl_insert(runlist_element *dst,$/;"	f	file:
ntfs_rl_mc	runlist.c	/^static inline void ntfs_rl_mc(runlist_element *dstbase, int dst,$/;"	f	file:
ntfs_rl_mm	runlist.c	/^static inline void ntfs_rl_mm(runlist_element *base, int dst, int src,$/;"	f	file:
ntfs_rl_punch_nolock	runlist.c	/^int ntfs_rl_punch_nolock(const ntfs_volume *vol, runlist *const runlist,$/;"	f
ntfs_rl_realloc	runlist.c	/^static inline runlist_element *ntfs_rl_realloc(runlist_element *rl,$/;"	f	file:
ntfs_rl_realloc_nofail	runlist.c	/^static inline runlist_element *ntfs_rl_realloc_nofail(runlist_element *rl,$/;"	f	file:
ntfs_rl_replace	runlist.c	/^static inline runlist_element *ntfs_rl_replace(runlist_element *dst,$/;"	f	file:
ntfs_rl_split	runlist.c	/^static inline runlist_element *ntfs_rl_split(runlist_element *dst, int dsize,$/;"	f	file:
ntfs_rl_truncate_nolock	runlist.c	/^int ntfs_rl_truncate_nolock(const ntfs_volume *vol, runlist *const runlist,$/;"	f
ntfs_rl_vcn_to_lcn	runlist.c	/^LCN ntfs_rl_vcn_to_lcn(const runlist_element *rl, const VCN vcn)$/;"	f
ntfs_runlists_merge	runlist.c	/^runlist_element *ntfs_runlists_merge(runlist_element *drl,$/;"	f
ntfs_set_next_iovec	file.c	/^static inline void ntfs_set_next_iovec(const struct iovec **iovp,$/;"	f	file:
ntfs_set_volume_flags	super.c	/^static inline int ntfs_set_volume_flags(ntfs_volume *vol, VOLUME_FLAGS flags)$/;"	f	file:
ntfs_setattr	inode.c	/^int ntfs_setattr(struct dentry *dentry, struct iattr *attr)$/;"	f
ntfs_setup_allocators	super.c	/^static void ntfs_setup_allocators(ntfs_volume *vol)$/;"	f	file:
ntfs_show_options	inode.c	/^int ntfs_show_options(struct seq_file *sf, struct vfsmount *mnt)$/;"	f
ntfs_sops	super.c	/^static const struct super_operations ntfs_sops = {$/;"	v	typeref:struct:super_operations	file:
ntfs_stamp_usnjrnl	usnjrnl.c	/^bool ntfs_stamp_usnjrnl(ntfs_volume *vol)$/;"	f
ntfs_statfs	super.c	/^static int ntfs_statfs(struct super_block *sb, struct kstatfs *sfs)$/;"	f	file:
ntfs_submit_bh_for_read	file.c	/^static inline int ntfs_submit_bh_for_read(struct buffer_head *bh)$/;"	f	file:
ntfs_sync_mft_mirror	mft.c	/^int ntfs_sync_mft_mirror(ntfs_volume *vol, const unsigned long mft_no,$/;"	f
ntfs_sync_mft_mirror_umount	mft.c	/^static int ntfs_sync_mft_mirror_umount(ntfs_volume *vol,$/;"	f	file:
ntfs_sysctl	sysctl.c	/^int ntfs_sysctl(int add)$/;"	f
ntfs_sysctl	sysctl.h	/^static inline int ntfs_sysctl(int add)$/;"	f
ntfs_sysctls	sysctl.c	/^static ctl_table ntfs_sysctls[] = {$/;"	v	file:
ntfs_test_inode	inode.c	/^int ntfs_test_inode(struct inode *vi, ntfs_attr *na)$/;"	f
ntfs_truncate	inode.c	/^int ntfs_truncate(struct inode *vi)$/;"	f
ntfs_truncate_vfs	inode.c	/^void ntfs_truncate_vfs(struct inode *vi) {$/;"	f
ntfs_ucsncasecmp	unistr.c	/^int ntfs_ucsncasecmp(const ntfschar *s1, const ntfschar *s2, size_t n,$/;"	f
ntfs_ucsncmp	unistr.c	/^int ntfs_ucsncmp(const ntfschar *s1, const ntfschar *s2, size_t n)$/;"	f
ntfs_ucstonls	unistr.c	/^int ntfs_ucstonls(const ntfs_volume *vol, const ntfschar *ins,$/;"	f
ntfs_unmap_page	aops.h	/^static inline void ntfs_unmap_page(struct page *page)$/;"	f
ntfs_upcase_name	unistr.c	/^void ntfs_upcase_name(ntfschar *name, u32 name_len, const ntfschar *upcase,$/;"	f
ntfs_volume	volume.h	/^} ntfs_volume;$/;"	t	typeref:struct:__anon4
ntfs_volume_flags	volume.h	/^} ntfs_volume_flags;$/;"	t	typeref:enum:__anon5
ntfs_warning	debug.h	57;"	d
ntfs_write_block	aops.c	/^static int ntfs_write_block(struct page *page, struct writeback_control *wbc)$/;"	f	file:
ntfs_write_inode	inode.c	/^int ntfs_write_inode(struct inode *vi, int sync)$/;"	f
ntfs_write_mst_block	aops.c	/^static int ntfs_write_mst_block(struct page *page,$/;"	f	file:
ntfs_write_significant_bytes	runlist.c	/^static inline int ntfs_write_significant_bytes(s8 *dst, const s8 *dst_max,$/;"	f	file:
ntfs_write_volume_flags	super.c	/^static int ntfs_write_volume_flags(ntfs_volume *vol, const VOLUME_FLAGS flags)$/;"	f	file:
ntfs_writepage	aops.c	/^static int ntfs_writepage(struct page *page, struct writeback_control *wbc)$/;"	f	file:
ntfschar	types.h	/^typedef le16 ntfschar;$/;"	t
number_of_sectors	layout.h	/^\/*0x28*\/sle64 number_of_sectors;	\/* Number of sectors in volume. Gives$/;"	m	struct:__anon32
object_flags	layout.h	/^\/*  8*\/	OBJECT_ACE_FLAGS object_flags;	\/* Flags describing the object ACE. *\/$/;"	m	struct:__anon79
object_id	layout.h	/^		GUID object_id;		\/* $O index in FILE_Extend\/$ObjId: The$/;"	m	union:__anon108::__anon112
object_id	layout.h	/^	GUID object_id;				\/* Unique id assigned to the$/;"	m	struct:__anon64
object_type	layout.h	/^\/* 12*\/	GUID object_type;$/;"	m	struct:__anon79
oem_id	layout.h	/^	le64 oem_id;			\/* Magic "NTFS    ". *\/$/;"	m	struct:__anon32
offset	layout.h	/^	le64 offset;	  \/* Byte offset of this entry in the $SDS stream. *\/$/;"	m	struct:__anon86
offset	layout.h	/^	le64 offset;	  \/* Byte offset of this entry in the $SDS stream. *\/$/;"	m	struct:__anon87
oldest_lsn	logfile.h	/^\/*  0*\/	leLSN oldest_lsn;	\/* Oldest LSN needed by this client.  On create$/;"	m	struct:__anon13
on_errors	volume.h	/^	u8 on_errors;			\/* What to do on filesystem errors. *\/$/;"	m	struct:__anon4
on_errors_arr	super.c	/^const option_t on_errors_arr[] = {$/;"	v
ops	lockdep.h	/^	unsigned long			ops;$/;"	m	struct:lock_class
opt	layout.h	/^	} __attribute__ ((__packed__)) opt;$/;"	m	struct:__anon61	typeref:union:__anon61::__anon62
opt	layout.h	/^	} __attribute__ ((__packed__)) opt;$/;"	m	struct:__anon64	typeref:union:__anon64::__anon65
option_t	ntfs.h	/^} option_t;$/;"	t	typeref:struct:__anon17
origin	layout.h	/^		} __attribute__ ((__packed__)) origin;$/;"	m	union:__anon61::__anon62	typeref:struct:__anon61::__anon62::__anon63
origin	layout.h	/^		} __attribute__ ((__packed__)) origin;$/;"	m	union:__anon64::__anon65	typeref:struct:__anon64::__anon65::__anon66
owner	layout.h	/^	SID *owner;	\/* Points to a SID representing an object's owner. If$/;"	m	struct:__anon84
owner	layout.h	/^	le32 owner;	\/* Byte offset to a SID representing an object's$/;"	m	struct:__anon83
owner	mutex.h	/^	struct thread_info	*owner;$/;"	m	struct:mutex	typeref:struct:mutex::thread_info
owner_id	layout.h	/^		\/* 48*\/	le32 owner_id;		\/* Owner_id of the user owning$/;"	m	struct:__anon50::__anon51::__anon53
owner_id	layout.h	/^		le32 owner_id;		\/* $Q index in FILE_Extend\/$Quota:$/;"	m	union:__anon108::__anon112
packed_ea_size	layout.h	/^		\/* 3c*\/	le16 packed_ea_size;	\/* Size of the buffer needed to$/;"	m	struct:__anon56::__anon57::__anon58
page	index.h	/^	struct page *page;$/;"	m	struct:__anon15	typeref:struct:__anon15::page
page	inode.h	/^	struct page *page;	\/* The page containing the mft record of the$/;"	m	struct:_ntfs_inode	typeref:struct:_ntfs_inode::page
page_ofs	inode.h	/^	int page_ofs;		\/* Offset into the page at which the mft record$/;"	m	struct:_ntfs_inode
parent_directory	layout.h	/^\/*  0*\/	leMFT_REF parent_directory;	\/* Directory this filename is$/;"	m	struct:__anon56
parent_directory	usnjrnl.h	/^\/*0x10*\/leMFT_REF parent_directory;\/* The mft reference of the parent$/;"	m	struct:__anon9
parse_ntfs_boot_sector	super.c	/^static bool parse_ntfs_boot_sector(ntfs_volume *vol, const NTFS_BOOT_SECTOR *b)$/;"	f	file:
parse_options	super.c	/^static bool parse_options(ntfs_volume *vol, char *opt)$/;"	f	file:
parts	layout.h	/^	} __attribute__ ((__packed__)) parts;$/;"	m	union:__anon68	typeref:struct:__anon68::__anon69
post_read_mst_fixup	mst.c	/^int post_read_mst_fixup(NTFS_RECORD *b, const u32 size)$/;"	f
post_write_mst_fixup	mst.c	/^void post_write_mst_fixup(NTFS_RECORD *b)$/;"	f
pre_write_mst_fixup	mst.c	/^int pre_write_mst_fixup(NTFS_RECORD *b, const u32 size)$/;"	f
prev_chain_key	lockdep.h	/^	u64				prev_chain_key;$/;"	m	struct:held_lock
prev_client	logfile.h	/^\/* 16*\/	le16 prev_client;	\/* The offset to the previous log client record$/;"	m	struct:__anon13
print_irqtrace_events	lockdep.h	/^static inline void print_irqtrace_events(struct task_struct *curr)$/;"	f
quota_charged	layout.h	/^		\/* 56*\/	le64 quota_charged;	\/* Byte size of the charge to$/;"	m	struct:__anon50::__anon51::__anon53
quota_ino	volume.h	/^	struct inode *quota_ino;	\/* The VFS inode of $Quota. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
quota_q_ino	volume.h	/^	struct inode *quota_q_ino;	\/* Attribute inode for $Quota\/$Q. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
read	lockdep.h	/^	unsigned int read:2;        \/* see lock_acquire() comment *\/$/;"	m	struct:held_lock
read_holdtime	lockdep.h	/^	struct lock_time		read_holdtime;$/;"	m	struct:lock_class_stats	typeref:struct:lock_class_stats::lock_time
read_mapping_page	ntfs_g.h	/^static inline struct page *read_mapping_page(struct address_space *mapping,$/;"	f
read_ntfs_boot_sector	super.c	/^static struct buffer_head *read_ntfs_boot_sector(struct super_block *sb,$/;"	f	file:
read_waittime	lockdep.h	/^	struct lock_time		read_waittime;$/;"	m	struct:lock_class_stats	typeref:struct:lock_class_stats::lock_time
reason	usnjrnl.h	/^\/*0x28*\/USN_REASON_FLAGS reason;\/* Reason flags (see above). *\/$/;"	m	struct:__anon9
reparse	layout.h	/^		REPARSE_INDEX_KEY reparse;	\/* $R index in$/;"	m	union:__anon108::__anon112
reparse_data	layout.h	/^	u8 reparse_data[0];		\/* Meaning depends on reparse_tag. *\/$/;"	m	struct:__anon115
reparse_data_length	layout.h	/^	le16 reparse_data_length;	\/* Byte size of reparse data. *\/$/;"	m	struct:__anon115
reparse_point_tag	layout.h	/^		\/* 3c*\/	le32 reparse_point_tag;	\/* Type of reparse point,$/;"	m	struct:__anon56::__anon57::__anon59
reparse_tag	layout.h	/^	le32 reparse_tag;		\/* Reparse point type (inc. flags). *\/$/;"	m	struct:__anon115
reparse_tag	layout.h	/^	le32 reparse_tag;	\/* Reparse point type (inc. flags). *\/$/;"	m	struct:__anon98
reserved	layout.h	/^		\/* 3e*\/	le16 reserved;		\/* Reserved for alignment. *\/$/;"	m	struct:__anon56::__anon57::__anon58
reserved	layout.h	/^	le16 reserved;			\/* Align to 8-byte boundary. *\/$/;"	m	struct:__anon115
reserved	layout.h	/^	le16 reserved;		 \/* Reserved\/align to 8-byte boundary. *\/$/;"	m	struct:__anon108
reserved	layout.h	/^	le64 reserved;		\/* Not used (yet?). *\/$/;"	m	struct:__anon92
reserved	layout.h	/^	u8 reserved[3];			\/* Reserved\/align to 8-byte boundary. *\/$/;"	m	struct:__anon95
reserved	layout.h	/^	u8 reserved[3];			\/* Reserved\/align to 8-byte boundary. *\/$/;"	m	struct:__anon96
reserved	layout.h	/^\/* 14*\/	le16 reserved;		 \/* Reserved\/align to 8-byte boundary. *\/$/;"	m	struct:__anon104
reserved	layout.h	/^\/* 23 *\/		s8 reserved;	  \/* Reserved\/alignment to 8-byte$/;"	m	struct:__anon45::__anon46::__anon47
reserved	layout.h	/^\/* 35*\/			u8 reserved[5];		\/* Align to 8-byte boundary. *\/$/;"	m	struct:__anon45::__anon46::__anon48
reserved	layout.h	/^\/* 42*\/ le16 reserved;		\/* Reserved\/alignment. *\/$/;"	m	struct:__anon37
reserved	logfile.h	/^\/* 22*\/	u8 reserved[6];		\/* Reserved\/alignment. *\/$/;"	m	struct:__anon13
reserved	logfile.h	/^\/* 44*\/	le32 reserved;		\/* Reserved\/alignment to 8-byte boundary. *\/$/;"	m	struct:__anon12
reserved0	layout.h	/^	u8  reserved0[3];		\/* zero *\/$/;"	m	struct:__anon32
reserved1	layout.h	/^	u8  reserved1[3];		\/* zero *\/$/;"	m	struct:__anon32
reserved12	layout.h	/^		\/* 36*\/	u8 reserved12[12];	\/* Reserved\/alignment to 8-byte$/;"	m	struct:__anon50::__anon51::__anon52
reservedV	layout.h	/^			le32 reservedV;		\/* Reserved (zero). *\/$/;"	m	struct:__anon104::__anon105::__anon107
reservedV	layout.h	/^			le32 reservedV;		\/* Reserved (zero). *\/$/;"	m	struct:__anon108::__anon109::__anon111
reserved_sectors	layout.h	/^	le16 reserved_sectors;		\/* zero *\/$/;"	m	struct:__anon31
resident	layout.h	/^		} __attribute__ ((__packed__)) resident;$/;"	m	union:__anon45::__anon46	typeref:struct:__anon45::__anon46::__anon47
restart_area_length	logfile.h	/^\/* 20*\/	le16 restart_area_length;\/* Length of the restart area including the$/;"	m	struct:__anon12
restart_area_offset	logfile.h	/^\/* 24*\/	le16 restart_area_offset;\/* Byte offset from the start of this header to$/;"	m	struct:__anon10
restart_log_open_count	logfile.h	/^\/* 40*\/	le32 restart_log_open_count;\/* A counter that gets incremented every$/;"	m	struct:__anon12
revision	layout.h	/^	u8 revision;	\/* Revision level of the security descriptor. *\/$/;"	m	struct:__anon83
revision	layout.h	/^	u8 revision;	\/* Revision level of the security descriptor. *\/$/;"	m	struct:__anon84
revision	layout.h	/^	u8 revision;	\/* Revision of this ACL. *\/$/;"	m	struct:__anon80
revision	layout.h	/^	u8 revision;$/;"	m	struct:__anon70
rl	runlist.h	/^	runlist_element *rl;$/;"	m	struct:__anon2
root_entries	layout.h	/^	le16 root_entries;		\/* zero *\/$/;"	m	struct:__anon31
root_ino	volume.h	/^	struct inode *root_ino;		\/* The VFS inode of the root$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
rp	layout.h	/^		} __attribute__ ((__packed__)) rp;$/;"	m	union:__anon56::__anon57	typeref:struct:__anon56::__anon57::__anon59
runlist	inode.h	/^	runlist runlist;	\/* If state has the NI_NonResident bit set,$/;"	m	struct:_ntfs_inode
runlist	runlist.h	/^} runlist;$/;"	t	typeref:struct:__anon2
runlist_element	runlist.h	/^} runlist_element;$/;"	t	typeref:struct:__anon1
rwlock_acquire	lockdep.h	436;"	d
rwlock_acquire	lockdep.h	439;"	d
rwlock_acquire	lockdep.h	444;"	d
rwlock_acquire_read	lockdep.h	437;"	d
rwlock_acquire_read	lockdep.h	440;"	d
rwlock_acquire_read	lockdep.h	445;"	d
rwlock_release	lockdep.h	442;"	d
rwlock_release	lockdep.h	446;"	d
rwsem_acquire	lockdep.h	463;"	d
rwsem_acquire	lockdep.h	466;"	d
rwsem_acquire	lockdep.h	471;"	d
rwsem_acquire_read	lockdep.h	464;"	d
rwsem_acquire_read	lockdep.h	467;"	d
rwsem_acquire_read	lockdep.h	472;"	d
rwsem_release	lockdep.h	469;"	d
rwsem_release	lockdep.h	473;"	d
sacl	layout.h	/^	ACL *sacl;	\/* Points to a system ACL. Only valid, if$/;"	m	struct:__anon84
sacl	layout.h	/^	le32 sacl;	\/* Byte offset to a system ACL. Only valid, if$/;"	m	struct:__anon83
sb	volume.h	/^	struct super_block *sb;		\/* Pointer back to the super_block. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::super_block
sb_has_dirty_inodes	ntfs_g.c	/^EXPORT_SYMBOL(sb_has_dirty_inodes);$/;"	v
sb_has_dirty_inodes	ntfs_g.c	/^int sb_has_dirty_inodes(struct super_block *sb)$/;"	f
sdh	layout.h	/^		SDH_INDEX_KEY sdh;	\/* $SDH index in $Secure. *\/$/;"	m	union:__anon108::__anon112
sector_size	volume.h	/^	u16 sector_size;		\/* in bytes *\/$/;"	m	struct:__anon4
sector_size_bits	volume.h	/^	u8 sector_size_bits;		\/* log2(sector_size) *\/$/;"	m	struct:__anon4
sectors	layout.h	/^	le16 sectors;			\/* zero *\/$/;"	m	struct:__anon31
sectors_per_cluster	layout.h	/^	u8  sectors_per_cluster;	\/* Size of a cluster in sectors. *\/$/;"	m	struct:__anon31
sectors_per_fat	layout.h	/^	le16 sectors_per_fat;		\/* zero *\/$/;"	m	struct:__anon31
sectors_per_track	layout.h	/^	le16 sectors_per_track;		\/* irrelevant *\/$/;"	m	struct:__anon31
secure_ino	volume.h	/^	struct inode *secure_ino;	\/* The VFS inode of $Secure (NTFS3.0+$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
security_id	layout.h	/^		\/* 52*\/	le32 security_id;	\/* Security_id for the file.$/;"	m	struct:__anon50::__anon51::__anon53
security_id	layout.h	/^	le32 security_id; \/* The security_id assigned to the descriptor. *\/$/;"	m	struct:__anon86
security_id	layout.h	/^	le32 security_id; \/* The security_id assigned to the descriptor. *\/$/;"	m	struct:__anon87
security_id	layout.h	/^	le32 security_id; \/* The security_id assigned to the descriptor. *\/$/;"	m	struct:__anon88
security_id	layout.h	/^	le32 security_id; \/* The security_id assigned to the descriptor. *\/$/;"	m	struct:__anon89
security_id	usnjrnl.h	/^\/*0x30*\/le32 security_id;	\/* File security_id copied from$/;"	m	struct:__anon9
security_inode_killpriv	ntfs_g.h	/^static inline int security_inode_killpriv(struct dentry *dentry)$/;"	f
security_inode_need_killpriv	ntfs_g.h	/^static inline int security_inode_need_killpriv(struct dentry *dentry)$/;"	f
seq_no	inode.h	/^	u16 seq_no;		\/* Sequence number of the mft record. *\/$/;"	m	struct:_ntfs_inode
seq_number	logfile.h	/^\/* 20*\/	le16 seq_number;	\/* On Win2k and presumably earlier, this is set$/;"	m	struct:__anon13
seq_number_bits	logfile.h	/^\/* 16*\/	le32 seq_number_bits;	\/* How many bits to use for the sequence$/;"	m	struct:__anon12
sequence_number	layout.h	/^\/* 16*\/	le16 sequence_number;	\/* Number of times this mft record has been$/;"	m	struct:__anon37
sequence_number	layout.h	/^\/* 16*\/	le16 sequence_number;	\/* Number of times this mft record has been$/;"	m	struct:__anon38
serial_no	volume.h	/^	u64 serial_no;			\/* The volume serial number. *\/$/;"	m	struct:__anon4
set_t	inode.c	/^typedef int (*set_t)(struct inode *, void *);$/;"	t	file:
should_remove_suid	ntfs_g.c	/^EXPORT_SYMBOL(should_remove_suid);$/;"	v
should_remove_suid	ntfs_g.c	/^int should_remove_suid(struct dentry *dentry)$/;"	f
sid	layout.h	/^		SID sid;		\/* $O index in FILE_Extend\/$Quota:$/;"	m	union:__anon108::__anon112
sid	layout.h	/^	SID sid;		\/* The SID of the user\/object associated with$/;"	m	struct:__anon100
sid	layout.h	/^\/*  8*\/	SID sid;		\/* The SID associated with the ACE. *\/$/;"	m	struct:__anon77
sid	layout.h	/^\/* 20*\/	SECURITY_DESCRIPTOR_RELATIVE sid; \/* The self-relative security$/;"	m	struct:__anon87
sid	layout.h	/^\/* 44*\/	SID sid;		\/* The SID associated with the ACE. *\/$/;"	m	struct:__anon79
sii	layout.h	/^		SII_INDEX_KEY sii;	\/* $SII index in $Secure. *\/$/;"	m	union:__anon108::__anon112
simple_getbool	super.c	/^static int simple_getbool(char *s, bool *setval)$/;"	f	file:
size	inode.h	/^			s64 size;		\/* Copy of compressed_size from$/;"	m	struct:_ntfs_inode::__anon24::__anon26
size	layout.h	/^	le16 size;		\/* Size in bytes of the ACE. *\/$/;"	m	struct:__anon77
size	layout.h	/^	le16 size;		\/* Size in bytes of the ACE. *\/$/;"	m	struct:__anon79
size	layout.h	/^	le16 size;	\/* Allocated space in bytes for ACL. Includes this$/;"	m	struct:__anon80
size	layout.h	/^\/*  2*\/	le16 size;		\/* Size in bytes of the ACE. *\/$/;"	m	struct:__anon74
size_lock	inode.h	/^	rwlock_t size_lock;	\/* Lock serializing access to inode sizes. *\/$/;"	m	struct:_ntfs_inode
sle16	types.h	/^typedef __u16 __bitwise sle16;$/;"	t
sle16_to_cpu	endian.h	/^static inline s16 sle16_to_cpu(sle16 x)$/;"	f
sle16_to_cpup	endian.h	/^static inline s16 sle16_to_cpup(sle16 *x)$/;"	f
sle32	types.h	/^typedef __u32 __bitwise sle32;$/;"	t
sle32_to_cpu	endian.h	/^static inline s32 sle32_to_cpu(sle32 x)$/;"	f
sle32_to_cpup	endian.h	/^static inline s32 sle32_to_cpup(sle32 *x)$/;"	f
sle64	types.h	/^typedef __u64 __bitwise sle64;$/;"	t
sle64_to_cpu	endian.h	/^static inline s64 sle64_to_cpu(sle64 x)$/;"	f
sle64_to_cpup	endian.h	/^static inline s64 sle64_to_cpup(sle64 *x)$/;"	f
source_info	usnjrnl.h	/^\/*0x2c*\/USN_SOURCE_INFO_FLAGS source_info;\/* Source info flags (see above). *\/$/;"	m	struct:__anon9
spin_acquire	lockdep.h	422;"	d
spin_acquire	lockdep.h	425;"	d
spin_acquire	lockdep.h	430;"	d
spin_acquire_nest	lockdep.h	423;"	d
spin_acquire_nest	lockdep.h	426;"	d
spin_release	lockdep.h	428;"	d
spin_release	lockdep.h	431;"	d
state	inode.h	/^	unsigned long state;	\/* NTFS specific flags describing this inode.$/;"	m	struct:_ntfs_inode
str	ntfs.h	/^	char *str;$/;"	m	struct:__anon17
sub_authority	layout.h	/^	le32 sub_authority[1];		\/* At least one sub_authority. *\/$/;"	m	struct:__anon70
sub_authority_count	layout.h	/^	u8 sub_authority_count;$/;"	m	struct:__anon70
subclass	lockdep.h	/^	unsigned int			subclass;$/;"	m	struct:lock_class
subkeys	lockdep.h	/^	struct lockdep_subclass_key	subkeys[MAX_LOCKDEP_SUBCLASSES];$/;"	m	struct:lock_class_key	typeref:struct:lock_class_key::lockdep_subclass_key
sysctls_root	sysctl.c	/^static ctl_table sysctls_root[] = {$/;"	v	file:
sysctls_root_table	sysctl.c	/^static struct ctl_table_header *sysctls_root_table = NULL;$/;"	v	typeref:struct:ctl_table_header	file:
system_page_size	logfile.h	/^\/* 16*\/	le32 system_page_size;	\/* Byte size of system pages when the log file$/;"	m	struct:__anon10
task	mutex.h	/^	struct task_struct	*task;$/;"	m	struct:mutex_waiter	typeref:struct:mutex_waiter::task_struct
test_and_set_bit_lock	ntfs_g.h	/^test_and_set_bit_lock(int nr, volatile unsigned long *addr)$/;"	f
test_t	inode.h	/^typedef int (*test_t)(struct inode *, void *);$/;"	t
threshold	layout.h	/^	sle64 threshold;	\/* Soft quota (-1 if not limited). *\/$/;"	m	struct:__anon100
time	usnjrnl.h	/^\/*0x20*\/sle64 time;		\/* Time when this record was created. *\/$/;"	m	struct:__anon9
total	lockdep.h	/^	s64				total;$/;"	m	struct:lock_time
trace	lockdep.h	/^	struct stack_trace		trace;$/;"	m	struct:lock_list	typeref:struct:lock_list::stack_trace
true	ntfs_g.h	/^typedef enum{false = 0, true} bool;$/;"	e	enum:__anon21
trylock	lockdep.h	/^	unsigned int trylock:1;$/;"	m	struct:held_lock
trylock_buffer	ntfs_g.h	/^static inline int trylock_buffer(struct buffer_head *bh)$/;"	f
type	dir.h	/^	FILE_NAME_TYPE_FLAGS type;$/;"	m	struct:__anon18
type	inode.h	/^	ATTR_TYPE type;	\/* Attribute type of this fake inode. *\/$/;"	m	struct:_ntfs_inode
type	inode.h	/^	ATTR_TYPE type;$/;"	m	struct:__anon30
type	layout.h	/^	ACE_TYPES type;		\/* Type of the ACE. *\/$/;"	m	struct:__anon77
type	layout.h	/^	ACE_TYPES type;		\/* Type of the ACE. *\/$/;"	m	struct:__anon79
type	layout.h	/^	ATTR_TYPE type;			\/* Type of the indexed attribute. Is$/;"	m	struct:__anon96
type	layout.h	/^	} __attribute__ ((__packed__)) type;$/;"	m	struct:__anon56	typeref:union:__anon56::__anon57
type	layout.h	/^\/*  0*\/	ACE_TYPES type;		\/* Type of the ACE. *\/$/;"	m	struct:__anon74
type	layout.h	/^\/*  0*\/	ATTR_TYPE type;		\/* The (32-bit) type of the attribute. *\/$/;"	m	struct:__anon45
type	layout.h	/^\/*  0*\/	ATTR_TYPE type;		\/* Type of referenced attribute. *\/$/;"	m	struct:__anon54
type	layout.h	/^\/* 80*\/	ATTR_TYPE type;			\/* Type of the attribute. *\/$/;"	m	struct:__anon42
uid	volume.h	/^	uid_t uid;			\/* uid that files will be mounted as. *\/$/;"	m	struct:__anon4
unmap_extent_mft_record	mft.h	/^static inline void unmap_extent_mft_record(ntfs_inode *ni)$/;"	f
unmap_mft_record	mft.c	/^void unmap_mft_record(ntfs_inode *ni)$/;"	f
unmap_mft_record_page	mft.c	/^static inline void unmap_mft_record_page(ntfs_inode *ni)$/;"	f	file:
unused	layout.h	/^	u8  unused[4];			\/* zero, NTFS diskedit.exe states that$/;"	m	struct:__anon32
upcase	volume.h	/^	ntfschar *upcase;		\/* The upcase table. *\/$/;"	m	struct:__anon4
upcase_len	volume.h	/^	u32 upcase_len;			\/* Number of entries in upcase[]. *\/$/;"	m	struct:__anon4
usa_count	layout.h	/^	le16 usa_count;		\/* Number of le16 sized entries in the usa$/;"	m	struct:__anon34
usa_count	layout.h	/^	le16 usa_count;		\/* See NTFS_RECORD definition above. *\/$/;"	m	struct:__anon37
usa_count	layout.h	/^	le16 usa_count;		\/* See NTFS_RECORD definition above. *\/$/;"	m	struct:__anon38
usa_count	layout.h	/^	le16 usa_count;		\/* See NTFS_RECORD definition. *\/$/;"	m	struct:__anon97
usa_count	logfile.h	/^\/*  6*\/	le16 usa_count;		\/* See NTFS_RECORD definition in layout.h. *\/$/;"	m	struct:__anon10
usa_ofs	layout.h	/^	le16 usa_ofs;		\/* Offset to the Update Sequence Array (usa)$/;"	m	struct:__anon34
usa_ofs	layout.h	/^	le16 usa_ofs;		\/* See NTFS_RECORD definition above. *\/$/;"	m	struct:__anon37
usa_ofs	layout.h	/^	le16 usa_ofs;		\/* See NTFS_RECORD definition above. *\/$/;"	m	struct:__anon38
usa_ofs	layout.h	/^	le16 usa_ofs;		\/* See NTFS_RECORD definition. *\/$/;"	m	struct:__anon97
usa_ofs	logfile.h	/^\/*  4*\/	le16 usa_ofs;		\/* See NTFS_RECORD definition in layout.h.$/;"	m	struct:__anon10
usage_mask	lockdep.h	/^	unsigned long			usage_mask;$/;"	m	struct:lock_class
usage_traces	lockdep.h	/^	struct stack_trace		usage_traces[XXX_LOCK_USAGE_STATES];$/;"	m	struct:lock_class	typeref:struct:lock_class::stack_trace
usn	layout.h	/^		\/* 64*\/	leUSN usn;		\/* Last update sequence number$/;"	m	struct:__anon50::__anon51::__anon53
usn	usnjrnl.h	/^\/*0x18*\/leUSN usn;		\/* The usn of this record.  Equals the offset$/;"	m	struct:__anon9
usnjrnl_ino	volume.h	/^	struct inode *usnjrnl_ino;	\/* The VFS inode of $UsnJrnl. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
usnjrnl_j_ino	volume.h	/^	struct inode *usnjrnl_j_ino;	\/* Attribute inode for $UsnJrnl\/$J. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
usnjrnl_max_ino	volume.h	/^	struct inode *usnjrnl_max_ino;	\/* Attribute inode for $UsnJrnl\/$Max. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
utc2ntfs	time.h	/^static inline sle64 utc2ntfs(const struct timespec ts)$/;"	f
v1	layout.h	/^		} __attribute__ ((__packed__)) v1;$/;"	m	union:__anon50::__anon51	typeref:struct:__anon50::__anon51::__anon52
v3	layout.h	/^		} __attribute__ ((__packed__)) v3;$/;"	m	union:__anon50::__anon51	typeref:struct:__anon50::__anon51::__anon53
val	ntfs.h	/^	int val;$/;"	m	struct:__anon17
value	layout.h	/^	u8 value[6];		\/* Value as individual bytes. *\/$/;"	m	union:__anon68
value_length	layout.h	/^\/* 16 *\/		le32 value_length;\/* Byte size of attribute value. *\/$/;"	m	struct:__anon45::__anon46::__anon47
value_offset	layout.h	/^\/* 20 *\/		le16 value_offset;\/* Byte offset of the attribute$/;"	m	struct:__anon45::__anon46::__anon47
vcn	runlist.h	/^	VCN vcn;	\/* vcn = Starting virtual cluster number. *\/$/;"	m	struct:__anon1
vcn_size	inode.h	/^			u32 vcn_size;		\/* Size of a vcn in this$/;"	m	struct:_ntfs_inode::__anon24::__anon25
vcn_size_bits	inode.h	/^			u8 vcn_size_bits;	\/* Log2 of the above. *\/$/;"	m	struct:_ntfs_inode::__anon24::__anon25
ver	layout.h	/^	} __attribute__ ((__packed__)) ver;$/;"	m	struct:__anon50	typeref:union:__anon50::__anon51
version	layout.h	/^	le32 version;		\/* Currently equals 2. *\/$/;"	m	struct:__anon100
version	lockdep.h	/^	unsigned int			version;$/;"	m	struct:lock_class
version_number	layout.h	/^		\/* 40*\/	le32 version_number;	\/* This file's version (if any).$/;"	m	struct:__anon50::__anon51::__anon53
vfs_inode	inode.h	/^	struct inode vfs_inode;		\/* The vfs inode structure. *\/$/;"	m	struct:__anon29	typeref:struct:__anon29::inode
vi	layout.h	/^		} __attribute__ ((__packed__)) vi;$/;"	m	union:__anon104::__anon105	typeref:struct:__anon104::__anon105::__anon107
vi	layout.h	/^		} __attribute__ ((__packed__)) vi;$/;"	m	union:__anon108::__anon109	typeref:struct:__anon108::__anon109::__anon111
vol	inode.h	/^	ntfs_volume *vol;	\/* Pointer to the ntfs volume of this inode. *\/$/;"	m	struct:_ntfs_inode
vol_flags	volume.h	/^	VOLUME_FLAGS vol_flags;		\/* Volume flags. *\/$/;"	m	struct:__anon4
vol_ino	volume.h	/^	struct inode *vol_ino;		\/* The VFS inode of $Volume. *\/$/;"	m	struct:__anon4	typeref:struct:__anon4::inode
volume_serial_number	layout.h	/^	le64 volume_serial_number;	\/* Irrelevant (serial number). *\/$/;"	m	struct:__anon32
wait_list	mutex.h	/^	struct list_head	wait_list;$/;"	m	struct:mutex	typeref:struct:mutex::list_head
wait_lock	mutex.h	/^	spinlock_t		wait_lock;$/;"	m	struct:mutex
waittime_stamp	lockdep.h	/^	u64 				waittime_stamp;$/;"	m	struct:held_lock
write_holdtime	lockdep.h	/^	struct lock_time		write_holdtime;$/;"	m	struct:lock_class_stats	typeref:struct:lock_class_stats::lock_time
write_mft_record	mft.h	/^static inline int write_mft_record(ntfs_inode *ni, MFT_RECORD *m, int sync)$/;"	f
write_mft_record_nolock	mft.c	/^int write_mft_record_nolock(ntfs_inode *ni, MFT_RECORD *m, int sync)$/;"	f
write_waittime	lockdep.h	/^	struct lock_time		write_waittime;$/;"	m	struct:lock_class_stats	typeref:struct:lock_class_stats::lock_time
zero_partial_compressed_page	compress.c	/^static void zero_partial_compressed_page(struct page *page,$/;"	f	file:
zero_user	ntfs_g.h	/^static inline void zero_user(struct page *page,$/;"	f
zero_user_segment	ntfs_g.h	/^static inline void zero_user_segment(struct page *page,$/;"	f
zero_user_segments	ntfs_g.h	/^static inline void zero_user_segments(struct page *page,$/;"	f
